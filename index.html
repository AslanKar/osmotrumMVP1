<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Осмотрум v5.5 — Local Mode</title>

  <!-- CSP добавим отдельной итерацией (по ТЗ нужен sha256-hash/nonce). Сейчас НЕ включаем, чтобы не “убить” запуск. -->
  <style>
    :root { --bg:#f6f7f9; --fg:#111; --muted:#666; --card:#fff; --line:#ddd; --accent:#2563eb; }
    body { margin:0; font:14px/1.4 system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; color:var(--fg); background:var(--bg); }
    header { background:#fff; border-bottom:1px solid var(--line); padding:12px 16px; position:sticky; top:0; z-index:10; }
    .wrap { max-width:980px; margin:0 auto; padding:16px; }
    .row { display:flex; gap:12px; flex-wrap:wrap; align-items:center; }
    .card { background:var(--card); border:1px solid var(--line); border-radius:10px; padding:14px; }
    .steps { display:flex; gap:8px; flex-wrap:wrap; }
    .stepBtn {
      border:1px solid var(--line); background:#fff; border-radius:999px; padding:8px 12px;
      cursor:pointer; user-select:none;
    }
    .stepBtn[aria-current="true"] { border-color:var(--accent); color:var(--accent); font-weight:600; }
    .muted { color:var(--muted); }
    .err { color:#b91c1c; font-weight:600; }
    .ok { color:#15803d; font-weight:600; }
    label { display:block; font-weight:600; margin:10px 0 6px; }
    input[type="text"], input[type="date"], textarea {
      width:100%; box-sizing:border-box; border:1px solid var(--line); border-radius:8px; padding:10px 10px;
      font:inherit; background:#fff;
    }
    textarea { min-height:90px; resize:vertical; }
    .actions { display:flex; gap:10px; flex-wrap:wrap; margin-top:14px; }
    .catTiles{
  display:grid;
  grid-template-columns:repeat(2, minmax(0, 1fr));
  gap:10px;
  margin-top:8px;
}
.catTile{
  display:flex;
  flex-direction:column;
  align-items:center;
  justify-content:center;
  min-height:88px;
  border-radius:14px;
}
.catTile.active{
  border-color: var(--accent);
}
.catTileIcon{ font-size:28px; line-height:1; }
.catTileLabel{ margin-top:6px; font-weight:700; }
    button {
      border:1px solid var(--line); background:#fff; border-radius:10px; padding:10px 12px; cursor:pointer;
    }
    button.primary { background:var(--accent); color:#fff; border-color:var(--accent); }
    button:disabled { opacity:.5; cursor:not-allowed; }
    .list { display:flex; flex-direction:column; gap:10px; margin-top:12px; }
    .item { display:flex; justify-content:space-between; gap:10px; align-items:center; }
    .pre { white-space:pre-wrap; background:#0b1020; color:#e5e7eb; padding:12px; border-radius:10px; overflow:auto; }
    details summary { cursor:pointer; user-select:none; }
    /* Photos UI (Iteration 4.2.3) */
.thumbGrid { display:grid; grid-template-columns:repeat(auto-fill, minmax(160px, 1fr)); gap:10px; margin-top:10px; }
.thumbCard { border:1px solid var(--line); border-radius:10px; padding:8px; background:#fff; }
.thumbImg { width:100%; height:110px; object-fit:cover; border-radius:8px; border:1px solid var(--line); background:#f3f4f6; }
.thumbMeta { font-size:12px; color:var(--muted); margin-top:6px; display:flex; justify-content:space-between; gap:8px; }
.thumbBtn { padding:6px 8px; border-radius:8px; }
/* 4.3.1 inline field errors (no red borders) */
.fieldError {
  margin-top: 6px;
  font-size: 12px;
  color: #b91c1c;
  display: none;
}
.reqStar {
  margin-left: 4px;
  color: var(--muted);
  font-weight: 900;
}
.reqStar.reqStarErr {
  color: #b91c1c;
}
    /* ===== Sticky Footer (по ТЗ) ===== */
    .stickyFooter{
      position: fixed;
      left: 0;
      right: 0;
      bottom: 0;
      background: #fff;
      border-top: 1px solid var(--line);
      box-shadow: 0 -4px 12px rgba(0,0,0,0.05);
      padding: 10px 16px calc(10px + env(safe-area-inset-bottom, 0px));
      z-index: 50;
    }
    .stickyFooterInner{
      max-width: 980px;
      margin: 0 auto;
    }

    /* В футере кнопки не должны иметь верхний отступ */
    .stickyFooter .actions { margin-top: 0; }

    /* Кнопки в футере нормальной высоты */
    .stickyFooter button { min-height: 48px; }

    /* Запас снизу у контента, чтобы футер НЕ перекрывал последний элемент */
    .wrap{
      padding-bottom: calc(var(--footerH, 80px) + 16px);
    }

    /* Когда клавиатура открыта: футер превращаем в обычный блок (static) */
    body.kbdOpen .stickyFooter{
      position: static;
      box-shadow: none;
      padding-bottom: 10px;
    }

    /* И в этом режиме запас снизу не нужен */
    body.kbdOpen .wrap{
      padding-bottom: 16px;
    }
  </style>
</head>
<body>
<header>
  <div class="row" style="justify-content:space-between; align-items:center;">
    <div style="font-weight:800;">Осмотрум - СОГАЗ</div>
    <div class="row">
      <button id="resetBtn" type="button">Новый осмотр</button>
    </div>
  </div>

  <!-- Скрытые элементы (нужны JS-логике, но не показываем в UI) -->
  <div style="display:none;">
    <div id="statusLine"></div>
    <div id="persistLine"></div>
    <input id="configFile" type="file" accept=".json,application/json" />
  </div>
</header>

<div class="wrap">
  <div class="card" id="stepperCard" style="display:none;">
    <div class="row" style="justify-content:space-between;">
      <div class="steps" id="steps"></div>
      <div class="muted" id="configMeta"></div>
    </div>
  </div>

  <div class="card" id="screen"></div>

    <!-- Sticky footer (по ТЗ): кнопки навигации фиксированы снизу -->
    <div id="stickyFooter" class="stickyFooter" style="display:none;">
      <div class="stickyFooterInner" id="stickyFooterInner"></div>
    </div>
  
    <div class="card" id="debugCard" style="margin-top:12px; display:none;">
      <details id="debugDetails">
        <summary><strong>Диагностика</strong> (state)</summary>
        <pre class="pre" id="debugPre"></pre>
      </details>
    </div>   

<!-- Встроенный Config.DB (fallback). Не исполняется, просто хранит JSON. -->
<textarea id="embeddedConfig" hidden>
  {
    "meta": {
      "product": "ОСМОТРУМ",
      "config_name": "Config.DB",
      "version": "5.5",
      "generated_at": "2026-01-22",
      "source_documents": [
        {
          "file": "ТЗ Осмотрум v.5.5.patched.v2.docx"
        },
        {
          "file": "База даных для Осмотрума.docx",
          "version": "5.0"
        }
      ],
      "notes": [
        "Списки: сортировка по алфавиту + специальные первые значения + общий хвост (только для явно перечисленных типов списков).",
        "Значение 'Иное' поддерживает inline-ввод: значение хранится как объект {choice:'Иное', other:'...'} для сохранения резолва шаблонов.",
        "Категория 'Остекление' повторяет набор полей Окно/Дверь как в 'Помещение' (с учётом различий справочников материалов).",
        "Поля по стеклу для элемента 'Дверь' отображаются только при выборе материала 'Стекло'.",
        "Размеры окна/двери добавлены после полей 'Тип окна' / 'Тип двери' (по уточнению пользователя)."
      ]
    },
    "constraints": {
      "photos": {
        "min_per_damage_item": 1,
        "max_per_damage_item": 10
      },
      "pdf": {
        "default_act_number": "№1",
        "act_date_source": "f_inspection_date"
      },
      "images": {
        "max_long_side_px": 2560,
        "target_max_bytes": 900000
      }
    },
    "dictionaries": [
      {
        "id": "d_common_tail",
        "label": "Общий хвост",
        "items": [
          {
            "value": "Иное"
          },
          {
            "value": "Не знаю / Затрудняюсь ответить"
          }
        ],
        "ordering": {
          "mode": "as_is",
          "special_first_values": [
            "Нет повреждений",
            "Нет утеплителя",
            "Нет изоляции",
            "Без пленки"
          ]
        }
      },
      {
        "id": "d_category",
        "label": "Категория",
        "items": [
          {
            "value": "Помещение"
          },
          {
            "value": "Здание"
          },
          {
            "value": "Мебель"
          },
          {
            "value": "Остекление"
          }
        ],
        "ordering": {
          "mode": "as_is",
          "special_first_values": [
            "Нет повреждений",
            "Нет утеплителя",
            "Нет изоляции",
            "Без пленки"
          ]
        }
      },
      {
        "id": "d_damage_char_common",
        "label": "Характер повреждений (Помещение / Здание / Мебель)",
        "items": [
          {
            "value": "Деформация"
          },
          {
            "value": "Загрязнение"
          },
          {
            "value": "Набухание"
          },
          {
            "value": "Намокание"
          },
          {
            "value": "Обгорание"
          },
          {
            "value": "Отслоение"
          },
          {
            "value": "Разрушение"
          },
          {
            "value": "Трещина"
          },
          {
            "value": "Иное"
          }
        ],
        "ordering": {
          "mode": "alpha_auto",
          "special_first_values": [
            "Нет повреждений",
            "Нет утеплителя",
            "Нет изоляции",
            "Без пленки"
          ]
        }
      },
      {
        "id": "d_damage_char_glazing",
        "label": "Характер повреждений (Остекление)",
        "items": [
          {
            "value": "Запотевание"
          },
          {
            "value": "Разрушение"
          },
          {
            "value": "Скол"
          },
          {
            "value": "Трещина"
          },
          {
            "value": "Царапина"
          },
          {
            "value": "Иное"
          }
        ],
        "ordering": {
          "mode": "alpha_auto",
          "special_first_values": [
            "Нет повреждений",
            "Нет утеплителя",
            "Нет изоляции",
            "Без пленки"
          ]
        }
      },
      {
        "id": "d_wood_species",
        "label": "Породы дерева",
        "items": [
          {
            "value": "Береза"
          },
          {
            "value": "Дуб"
          },
          {
            "value": "Ель"
          },
          {
            "value": "Клен"
          },
          {
            "value": "Лиственница"
          }
        ],
        "dict_type": "Детализация",
        "tail_id": "d_common_tail",
        "ordering": {
          "mode": "alpha_auto",
          "special_first_values": [
            "Нет повреждений",
            "Нет утеплителя",
            "Нет изоляции",
            "Без пленки"
          ]
        }
      },
      {
        "id": "d_metal_details",
        "label": "Детализация (металл)",
        "items": [
          {
            "value": "алюминий"
          },
          {
            "value": "сталь"
          }
        ],
        "dict_type": "Детализация",
        "tail_id": "d_common_tail",
        "ordering": {
          "mode": "alpha_auto",
          "special_first_values": [
            "Нет повреждений",
            "Нет утеплителя",
            "Нет изоляции",
            "Без пленки"
          ]
        }
      },
      {
        "id": "d_unit_m",
        "label": "Единица измерения",
        "items": [
          {
            "value": "м"
          }
        ],
        "ordering": {
          "mode": "as_is",
          "special_first_values": [
            "Нет повреждений",
            "Нет утеплителя",
            "Нет изоляции",
            "Без пленки"
          ]
        }
      },
      {
        "id": "d_unit_cm_m",
        "label": "Единица измерения",
        "items": [
          {
            "value": "см"
          },
          {
            "value": "м"
          }
        ],
        "ordering": {
          "mode": "as_is",
          "special_first_values": [
            "Нет повреждений",
            "Нет утеплителя",
            "Нет изоляции",
            "Без пленки"
          ]
        }
      },
      {
        "id": "d_unit_mm",
        "label": "Единица измерения",
        "items": [
          {
            "value": "мм"
          }
        ],
        "ordering": {
          "mode": "as_is",
          "special_first_values": [
            "Нет повреждений",
            "Нет утеплителя",
            "Нет изоляции",
            "Без пленки"
          ]
        }
      },
      {
        "id": "d_element_room",
        "label": "Элемент (Помещение)",
        "items": [
          {
            "value": "Потолок"
          },
          {
            "value": "Стена"
          },
          {
            "value": "Пол"
          },
          {
            "value": "Окно"
          },
          {
            "value": "Дверь"
          }
        ],
        "dict_type": "Элемент",
        "tail_id": "d_common_tail",
        "ordering": {
          "mode": "alpha_auto",
          "special_first_values": [
            "Нет повреждений",
            "Нет утеплителя",
            "Нет изоляции",
            "Без пленки"
          ]
        }
      },
      {
        "id": "d_element_building",
        "label": "Элемент (Здание)",
        "items": [
          {
            "value": "Фасад"
          },
          {
            "value": "Крыша"
          },
          {
            "value": "Архитектурные элементы"
          },
          {
            "value": "Конструктивные элементы"
          }
        ],
        "dict_type": "Элемент",
        "tail_id": "d_common_tail",
        "ordering": {
          "mode": "alpha_auto",
          "special_first_values": [
            "Нет повреждений",
            "Нет утеплителя",
            "Нет изоляции",
            "Без пленки"
          ]
        }
      },
      {
        "id": "d_element_glazing",
        "label": "Элемент (Остекление)",
        "items": [
          {
            "value": "Дверь"
          },
          {
            "value": "Окно"
          }
        ],
        "dict_type": "Элемент",
        "tail_id": "d_common_tail",
        "ordering": {
          "mode": "alpha_auto",
          "special_first_values": [
            "Нет повреждений",
            "Нет утеплителя",
            "Нет изоляции",
            "Без пленки"
          ]
        }
      },
      {
        "id": "d_room_ceiling_subelement",
        "label": "Подэлемент (Потолок)",
        "items": [
          {
            "value": "Армстронг"
          },
          {
            "value": "Вагонка"
          },
          {
            "value": "Декоративная штукатурка"
          },
          {
            "value": "Кассетный потолок"
          },
          {
            "value": "Лакокрасочное покрытие"
          },
          {
            "value": "Натяжной потолок"
          },
          {
            "value": "Обои"
          },
          {
            "value": "Плинтус потолочный"
          },
          {
            "value": "Побелка"
          },
          {
            "value": "Подвесной потолок"
          },
          {
            "value": "Потолочная плитка"
          },
          {
            "value": "Реечный потолок"
          }
        ],
        "dict_type": "Подэлемент",
        "tail_id": "d_common_tail",
        "ordering": {
          "mode": "alpha_auto",
          "special_first_values": [
            "Нет повреждений",
            "Нет утеплителя",
            "Нет изоляции",
            "Без пленки"
          ]
        }
      },
      {
        "id": "d_room_wall_subelement",
        "label": "Подэлемент (Стена)",
        "items": [
          {
            "value": "Дверные откосы"
          },
          {
            "value": "Оконные откосы"
          },
          {
            "value": "Стеновые панели"
          },
          {
            "value": "Ламинат"
          },
          {
            "value": "Декоративная штукатурка"
          },
          {
            "value": "Декоративный камень"
          },
          {
            "value": "Лакокрасочное покрытие"
          },
          {
            "value": "Обои"
          },
          {
            "value": "Плитка"
          },
          {
            "value": "Побелка"
          }
        ],
        "dict_type": "Подэлемент",
        "tail_id": "d_common_tail",
        "ordering": {
          "mode": "alpha_auto",
          "special_first_values": [
            "Нет повреждений",
            "Нет утеплителя",
            "Нет изоляции",
            "Без пленки"
          ]
        }
      },
      {
        "id": "d_room_floor_subelement",
        "label": "Подэлемент (Пол)",
        "items": [
          {
            "value": "Ковролин"
          },
          {
            "value": "Линолеум"
          },
          {
            "value": "Плинтус напольный"
          },
          {
            "value": "Плитка"
          },
          {
            "value": "Паркет"
          },
          {
            "value": "Ламинат"
          }
        ],
        "dict_type": "Подэлемент",
        "tail_id": "d_common_tail",
        "ordering": {
          "mode": "alpha_auto",
          "special_first_values": [
            "Нет повреждений",
            "Нет утеплителя",
            "Нет изоляции",
            "Без пленки"
          ]
        }
      },
      {
        "id": "d_ceiling_armstrong_material",
        "label": "Материал (Потолок: Армстронг)",
        "items": [
          {
            "value": "Металл"
          },
          {
            "value": "Минеральное волокно"
          },
          {
            "value": "ПВХ"
          },
          {
            "value": "Стекло"
          }
        ],
        "dict_type": "Материал",
        "tail_id": "d_common_tail",
        "ordering": {
          "mode": "alpha_auto",
          "special_first_values": [
            "Нет повреждений",
            "Нет утеплителя",
            "Нет изоляции",
            "Без пленки"
          ]
        }
      },
      {
        "id": "d_ceiling_decorplaster_view",
        "label": "Вид (Потолок: Декоративная штукатурка)",
        "items": [
          {
            "value": "Акриловая"
          },
          {
            "value": "Минеральная"
          },
          {
            "value": "Силикатная"
          },
          {
            "value": "Силиконовая"
          }
        ],
        "dict_type": "Вид",
        "tail_id": "d_common_tail",
        "ordering": {
          "mode": "alpha_auto",
          "special_first_values": [
            "Нет повреждений",
            "Нет утеплителя",
            "Нет изоляции",
            "Без пленки"
          ]
        }
      },
      {
        "id": "d_ceiling_cassette_material",
        "label": "Материал (Потолок: Кассетный потолок)",
        "items": [
          {
            "value": "Металл"
          },
          {
            "value": "Минеральное волокно"
          },
          {
            "value": "ПВС сетка"
          },
          {
            "value": "Стеклянный"
          }
        ],
        "dict_type": "Материал",
        "tail_id": "d_common_tail",
        "ordering": {
          "mode": "alpha_auto",
          "special_first_values": [
            "Нет повреждений",
            "Нет утеплителя",
            "Нет изоляции",
            "Без пленки"
          ]
        }
      },
      {
        "id": "d_ceiling_paint_view",
        "label": "Вид (Потолок: Лакокрасочное покрытие)",
        "items": [
          {
            "value": "Акриловое"
          },
          {
            "value": "Водоэмульсионное"
          },
          {
            "value": "Известковое"
          },
          {
            "value": "Резиновое"
          },
          {
            "value": "Силикатное"
          },
          {
            "value": "Силиконовое"
          },
          {
            "value": "Силоксановое"
          },
          {
            "value": "Фактурное"
          }
        ],
        "dict_type": "Вид",
        "tail_id": "d_common_tail",
        "ordering": {
          "mode": "alpha_auto",
          "special_first_values": [
            "Нет повреждений",
            "Нет утеплителя",
            "Нет изоляции",
            "Без пленки"
          ]
        }
      },
      {
        "id": "d_ceiling_stretch_view",
        "label": "Вид (Потолок: Натяжной потолок)",
        "items": [
          {
            "value": "ПВХ"
          },
          {
            "value": "Пленка"
          },
          {
            "value": "Тканевый"
          }
        ],
        "dict_type": "Вид",
        "tail_id": "d_common_tail",
        "ordering": {
          "mode": "alpha_auto",
          "special_first_values": [
            "Нет повреждений",
            "Нет утеплителя",
            "Нет изоляции",
            "Без пленки"
          ]
        }
      },
      {
        "id": "d_ceiling_stretch_texture",
        "label": "Фактура (Потолок: Натяжной потолок)",
        "items": [
          {
            "value": "Матовый"
          },
          {
            "value": "Глянцевый"
          }
        ],
        "dict_type": "Фактура",
        "tail_id": "d_common_tail",
        "ordering": {
          "mode": "alpha_auto",
          "special_first_values": [
            "Нет повреждений",
            "Нет утеплителя",
            "Нет изоляции",
            "Без пленки"
          ]
        }
      },
      {
        "id": "d_ceiling_wallpaper_type",
        "label": "Тип (Потолок: Обои)",
        "items": [
          {
            "value": "Бумажные"
          },
          {
            "value": "Виниловые"
          },
          {
            "value": "Моющиеся"
          },
          {
            "value": "Под покраску"
          },
          {
            "value": "Стеклохолст"
          },
          {
            "value": "Флизилиновые"
          }
        ],
        "dict_type": "Тип",
        "tail_id": "d_common_tail",
        "ordering": {
          "mode": "alpha_auto",
          "special_first_values": [
            "Нет повреждений",
            "Нет утеплителя",
            "Нет изоляции",
            "Без пленки"
          ]
        }
      },
      {
        "id": "d_ceiling_plinth_material",
        "label": "Материал (Потолок: Плинтус потолочный)",
        "items": [
          {
            "value": "Береза"
          },
          {
            "value": "Дуб"
          },
          {
            "value": "Ель"
          },
          {
            "value": "Клен"
          },
          {
            "value": "Лиственница"
          },
          {
            "value": "ПВХ"
          },
          {
            "value": "Пенопласт"
          },
          {
            "value": "Полиуретан"
          }
        ],
        "dict_type": "Материал",
        "tail_id": "d_common_tail",
        "ordering": {
          "mode": "alpha_auto",
          "special_first_values": [
            "Нет повреждений",
            "Нет утеплителя",
            "Нет изоляции",
            "Без пленки"
          ]
        }
      },
      {
        "id": "d_ceiling_whitewash_view",
        "label": "Вид (Потолок: Побелка)",
        "items": [
          {
            "value": "Водоэмульсионная"
          },
          {
            "value": "Известковая"
          },
          {
            "value": "Меловая"
          }
        ],
        "dict_type": "Вид",
        "tail_id": "d_common_tail",
        "ordering": {
          "mode": "alpha_auto",
          "special_first_values": [
            "Нет повреждений",
            "Нет утеплителя",
            "Нет изоляции",
            "Без пленки"
          ]
        }
      },
      {
        "id": "d_ceiling_suspended_type",
        "label": "Тип (Потолок: Подвесной потолок)",
        "items": [
          {
            "value": "Гипсокартонный"
          }
        ],
        "dict_type": "Тип",
        "tail_id": "d_common_tail",
        "ordering": {
          "mode": "alpha_auto",
          "special_first_values": [
            "Нет повреждений",
            "Нет утеплителя",
            "Нет изоляции",
            "Без пленки"
          ]
        }
      },
      {
        "id": "d_ceiling_tile_material",
        "label": "Материал (Потолок: Потолочная плитка)",
        "items": [
          {
            "value": "Береза"
          },
          {
            "value": "Дуб"
          },
          {
            "value": "Ель"
          },
          {
            "value": "Клен"
          },
          {
            "value": "Лиственница"
          },
          {
            "value": "Минеральное волокно"
          },
          {
            "value": "ПВХ"
          },
          {
            "value": "Пенополистирол"
          }
        ],
        "dict_type": "Материал",
        "tail_id": "d_common_tail",
        "ordering": {
          "mode": "alpha_auto",
          "special_first_values": [
            "Нет повреждений",
            "Нет утеплителя",
            "Нет изоляции",
            "Без пленки"
          ]
        }
      },
      {
        "id": "d_ceiling_rack_material",
        "label": "Материал (Потолок: Реечный потолок)",
        "items": [
          {
            "value": "Береза"
          },
          {
            "value": "Дуб"
          },
          {
            "value": "Ель"
          },
          {
            "value": "Клен"
          },
          {
            "value": "Лиственница"
          },
          {
            "value": "Металл"
          },
          {
            "value": "ПВХ"
          }
        ],
        "dict_type": "Материал",
        "tail_id": "d_common_tail",
        "ordering": {
          "mode": "alpha_auto",
          "special_first_values": [
            "Нет повреждений",
            "Нет утеплителя",
            "Нет изоляции",
            "Без пленки"
          ]
        }
      },
      {
        "id": "d_wall_slopes_material",
        "label": "Материал (Стена: откосы)",
        "items": [
          {
            "value": "Гипсокартон"
          },
          {
            "value": "Береза"
          },
          {
            "value": "Дуб"
          },
          {
            "value": "Ель"
          },
          {
            "value": "Клен"
          },
          {
            "value": "Лиственница"
          },
          {
            "value": "ДСП"
          },
          {
            "value": "МДФ"
          },
          {
            "value": "Металл"
          },
          {
            "value": "Пластик"
          },
          {
            "value": "Сэндвич-панель"
          },
          {
            "value": "Штукатурка"
          },
          {
            "value": "Плитка"
          }
        ],
        "dict_type": "Материал",
        "tail_id": "d_common_tail",
        "ordering": {
          "mode": "alpha_auto",
          "special_first_values": [
            "Нет повреждений",
            "Нет утеплителя",
            "Нет изоляции",
            "Без пленки"
          ]
        }
      },
      {
        "id": "d_wall_panels_material",
        "label": "Материал (Стена: Стеновые панели)",
        "items": [
          {
            "value": "Гипс"
          },
          {
            "value": "Береза"
          },
          {
            "value": "Дуб"
          },
          {
            "value": "Ель"
          },
          {
            "value": "Клен"
          },
          {
            "value": "Лиственница"
          },
          {
            "value": "ДСП"
          },
          {
            "value": "Камень"
          },
          {
            "value": "МДФ"
          },
          {
            "value": "ПВХ"
          },
          {
            "value": "Стекло"
          }
        ],
        "dict_type": "Материал",
        "tail_id": "d_common_tail",
        "ordering": {
          "mode": "alpha_auto",
          "special_first_values": [
            "Нет повреждений",
            "Нет утеплителя",
            "Нет изоляции",
            "Без пленки"
          ]
        }
      },
      {
        "id": "d_wall_laminate_view",
        "label": "Вид (Стена: Ламинат)",
        "items": [
          {
            "value": "HDF"
          },
          {
            "value": "LVT"
          },
          {
            "value": "SPC"
          }
        ],
        "dict_type": "Вид",
        "tail_id": "d_common_tail",
        "ordering": {
          "mode": "alpha_auto",
          "special_first_values": [
            "Нет повреждений",
            "Нет утеплителя",
            "Нет изоляции",
            "Без пленки"
          ]
        }
      },
      {
        "id": "d_laminate_class",
        "label": "Класс ламината",
        "items": [
          {
            "value": "21 (бытовой)"
          },
          {
            "value": "22 (бытовой)"
          },
          {
            "value": "23 (бытовой)"
          },
          {
            "value": "31 (коммерческий)"
          },
          {
            "value": "32 (коммерческий)"
          },
          {
            "value": "33 (коммерческий)"
          },
          {
            "value": "34 (коммерческий)"
          }
        ],
        "dict_type": "Класс ламината",
        "tail_id": "d_common_tail",
        "ordering": {
          "mode": "alpha_auto",
          "special_first_values": [
            "Нет повреждений",
            "Нет утеплителя",
            "Нет изоляции",
            "Без пленки"
          ]
        }
      },
      {
        "id": "d_wall_decorplaster_view",
        "label": "Вид (Стена: Декоративная штукатурка)",
        "items": [
          {
            "value": "Минеральная"
          },
          {
            "value": "Акриловая"
          },
          {
            "value": "Силикатная"
          },
          {
            "value": "Силиконовая"
          }
        ],
        "dict_type": "Вид",
        "tail_id": "d_common_tail",
        "ordering": {
          "mode": "alpha_auto",
          "special_first_values": [
            "Нет повреждений",
            "Нет утеплителя",
            "Нет изоляции",
            "Без пленки"
          ]
        }
      },
      {
        "id": "d_wall_paint_view",
        "label": "Вид (Стена: Лакокрасочное покрытие)",
        "items": [
          {
            "value": "Акриловое"
          },
          {
            "value": "Водоэмульсионное"
          },
          {
            "value": "Силикатное"
          },
          {
            "value": "Известковое"
          }
        ],
        "dict_type": "Вид",
        "tail_id": "d_common_tail",
        "ordering": {
          "mode": "alpha_auto",
          "special_first_values": [
            "Нет повреждений",
            "Нет утеплителя",
            "Нет изоляции",
            "Без пленки"
          ]
        }
      },
      {
        "id": "d_wall_wallpaper_type",
        "label": "Тип (Стена: Обои)",
        "items": [
          {
            "value": "Бумажные"
          },
          {
            "value": "Виниловые"
          },
          {
            "value": "Под покраску"
          },
          {
            "value": "Флизилиновые"
          }
        ],
        "dict_type": "Тип",
        "tail_id": "d_common_tail",
        "ordering": {
          "mode": "alpha_auto",
          "special_first_values": [
            "Нет повреждений",
            "Нет утеплителя",
            "Нет изоляции",
            "Без пленки"
          ]
        }
      },
      {
        "id": "d_tile_view",
        "label": "Вид (Плитка)",
        "items": [
          {
            "value": "Керамическая"
          },
          {
            "value": "Керамогранит"
          },
          {
            "value": "Клинкерная"
          }
        ],
        "dict_type": "Вид",
        "tail_id": "d_common_tail",
        "ordering": {
          "mode": "alpha_auto",
          "special_first_values": [
            "Нет повреждений",
            "Нет утеплителя",
            "Нет изоляции",
            "Без пленки"
          ]
        }
      },
      {
        "id": "d_wall_whitewash_type",
        "label": "Тип (Стена: Побелка)",
        "items": [
          {
            "value": "Водоэмульсионная"
          },
          {
            "value": "Известковая"
          },
          {
            "value": "Меловая"
          }
        ],
        "dict_type": "Тип",
        "tail_id": "d_common_tail",
        "ordering": {
          "mode": "alpha_auto",
          "special_first_values": [
            "Нет повреждений",
            "Нет утеплителя",
            "Нет изоляции",
            "Без пленки"
          ]
        }
      },
      {
        "id": "d_floor_carpet_type",
        "label": "Тип (Пол: Ковролин)",
        "items": [
          {
            "value": "Джутовый"
          },
          {
            "value": "Латексный"
          },
          {
            "value": "Резиновый"
          }
        ],
        "dict_type": "Тип",
        "tail_id": "d_common_tail",
        "ordering": {
          "mode": "alpha_auto",
          "special_first_values": [
            "Нет повреждений",
            "Нет утеплителя",
            "Нет изоляции",
            "Без пленки"
          ]
        }
      },
      {
        "id": "d_floor_lino_type",
        "label": "Тип (Пол: Линолеум)",
        "items": [
          {
            "value": "Алкидный"
          },
          {
            "value": "Натуральный"
          },
          {
            "value": "ПВХ"
          },
          {
            "value": "Резиновый"
          }
        ],
        "dict_type": "Тип",
        "tail_id": "d_common_tail",
        "ordering": {
          "mode": "alpha_auto",
          "special_first_values": [
            "Нет повреждений",
            "Нет утеплителя",
            "Нет изоляции",
            "Без пленки"
          ]
        }
      },
      {
        "id": "d_floor_plinth_material",
        "label": "Материал (Пол: Плинтус напольный)",
        "items": [
          {
            "value": "Береза"
          },
          {
            "value": "Дуб"
          },
          {
            "value": "Ель"
          },
          {
            "value": "Клен"
          },
          {
            "value": "Лиственница"
          },
          {
            "value": "МДФ"
          },
          {
            "value": "Металл"
          },
          {
            "value": "ПВХ"
          }
        ],
        "dict_type": "Материал",
        "tail_id": "d_common_tail",
        "ordering": {
          "mode": "alpha_auto",
          "special_first_values": [
            "Нет повреждений",
            "Нет утеплителя",
            "Нет изоляции",
            "Без пленки"
          ]
        }
      },
      {
        "id": "d_floor_parquet_view",
        "label": "Вид (Пол: Паркет)",
        "items": [
          {
            "value": "Наборный"
          },
          {
            "value": "Штучный"
          },
          {
            "value": "Щитовой"
          },
          {
            "value": "Доска"
          }
        ],
        "dict_type": "Вид",
        "tail_id": "d_common_tail",
        "ordering": {
          "mode": "alpha_auto",
          "special_first_values": [
            "Нет повреждений",
            "Нет утеплителя",
            "Нет изоляции",
            "Без пленки"
          ]
        }
      },
      {
        "id": "d_floor_laminate_details",
        "label": "Детали (Пол: Ламинат)",
        "items": [
          {
            "value": "HDF"
          },
          {
            "value": "LVT"
          },
          {
            "value": "SPC"
          }
        ],
        "dict_type": "Детализация",
        "tail_id": "d_common_tail",
        "ordering": {
          "mode": "alpha_auto",
          "special_first_values": [
            "Нет повреждений",
            "Нет утеплителя",
            "Нет изоляции",
            "Без пленки"
          ]
        }
      },
      {
        "id": "d_room_window_material",
        "label": "Материал (Помещение: Окно)",
        "items": [
          {
            "value": "Дерево"
          },
          {
            "value": "Металл"
          },
          {
            "value": "Пластик"
          }
        ],
        "dict_type": "Материал",
        "tail_id": "d_common_tail",
        "ordering": {
          "mode": "alpha_auto",
          "special_first_values": [
            "Нет повреждений",
            "Нет утеплителя",
            "Нет изоляции",
            "Без пленки"
          ]
        }
      },
      {
        "id": "d_room_door_material",
        "label": "Материал (Помещение: Дверь)",
        "items": [
          {
            "value": "Дерево"
          },
          {
            "value": "Металл"
          },
          {
            "value": "Пластик"
          },
          {
            "value": "Стекло"
          }
        ],
        "dict_type": "Материал",
        "tail_id": "d_common_tail",
        "ordering": {
          "mode": "alpha_auto",
          "special_first_values": [
            "Нет повреждений",
            "Нет утеплителя",
            "Нет изоляции",
            "Без пленки"
          ]
        }
      },
      {
        "id": "d_window_type",
        "label": "Тип окна",
        "items": [
          {
            "value": "Распашное"
          },
          {
            "value": "Раздвижное"
          },
          {
            "value": "Панорамное"
          },
          {
            "value": "Распашное безрамное"
          },
          {
            "value": "Раздвижное безрамное"
          },
          {
            "value": "Панорамное безрамное"
          }
        ],
        "dict_type": "Тип окна",
        "tail_id": "d_common_tail",
        "ordering": {
          "mode": "alpha_auto",
          "special_first_values": [
            "Нет повреждений",
            "Нет утеплителя",
            "Нет изоляции",
            "Без пленки"
          ]
        }
      },
      {
        "id": "d_door_type",
        "label": "Тип двери",
        "items": [
          {
            "value": "Распашная"
          },
          {
            "value": "Раздвижная"
          },
          {
            "value": "Распашная безрамная"
          },
          {
            "value": "Раздвижная безрамная"
          }
        ],
        "dict_type": "Тип двери",
        "tail_id": "d_common_tail",
        "ordering": {
          "mode": "alpha_auto",
          "special_first_values": [
            "Нет повреждений",
            "Нет утеплителя",
            "Нет изоляции",
            "Без пленки"
          ]
        }
      },
      {
        "id": "d_glass_type_window",
        "label": "Тип стекла (Окно)",
        "items": [
          {
            "value": "Закаленное"
          },
          {
            "value": "Ударопрочное"
          },
          {
            "value": "Бронированное"
          },
          {
            "value": "Стандартное"
          }
        ],
        "dict_type": "Тип стекла",
        "tail_id": "d_common_tail",
        "ordering": {
          "mode": "alpha_auto",
          "special_first_values": [
            "Нет повреждений",
            "Нет утеплителя",
            "Нет изоляции",
            "Без пленки"
          ]
        }
      },
      {
        "id": "d_glass_type_door_room",
        "label": "Тип стекла (Дверь: Помещение)",
        "items": [
          {
            "value": "Закаленное"
          },
          {
            "value": "Ударопрочное"
          },
          {
            "value": "Бронированное"
          }
        ],
        "dict_type": "Тип стекла",
        "tail_id": "d_common_tail",
        "ordering": {
          "mode": "alpha_auto",
          "special_first_values": [
            "Нет повреждений",
            "Нет утеплителя",
            "Нет изоляции",
            "Без пленки"
          ]
        }
      },
      {
        "id": "d_glass_type_door_glazing",
        "label": "Тип стекла (Дверь: Остекление)",
        "items": [
          {
            "value": "Закаленное"
          },
          {
            "value": "Ударопрочное"
          },
          {
            "value": "Бронированное"
          },
          {
            "value": "Стандартное"
          }
        ],
        "dict_type": "Тип стекла",
        "tail_id": "d_common_tail",
        "ordering": {
          "mode": "alpha_auto",
          "special_first_values": [
            "Нет повреждений",
            "Нет утеплителя",
            "Нет изоляции",
            "Без пленки"
          ]
        }
      },
      {
        "id": "d_cameras",
        "label": "Кол-во камер",
        "items": [
          {
            "value": "Бескамерное"
          },
          {
            "value": "Однокамерное"
          },
          {
            "value": "Двухкамерное"
          }
        ],
        "dict_type": "Кол-во камер",
        "tail_id": "d_common_tail",
        "ordering": {
          "mode": "alpha_auto",
          "special_first_values": [
            "Нет повреждений",
            "Нет утеплителя",
            "Нет изоляции",
            "Без пленки"
          ]
        }
      },
      {
        "id": "d_film_type",
        "label": "Вид пленки",
        "items": [
          {
            "value": "Солнцезащитная"
          },
          {
            "value": "Энергосберегающая"
          },
          {
            "value": "Противоударная"
          },
          {
            "value": "Без пленки"
          }
        ],
        "ordering": {
          "mode": "alpha_auto",
          "special_first_values": [
            "Нет повреждений",
            "Нет утеплителя",
            "Нет изоляции",
            "Без пленки"
          ]
        }
      },
      {
        "id": "d_glazing_window_material",
        "label": "Материал (Остекление: Окно)",
        "items": [
          {
            "value": "Дерево"
          },
          {
            "value": "Металл"
          },
          {
            "value": "Пластик"
          },
          {
            "value": "Стекло"
          }
        ],
        "dict_type": "Материал",
        "tail_id": "d_common_tail",
        "ordering": {
          "mode": "alpha_auto",
          "special_first_values": [
            "Нет повреждений",
            "Нет утеплителя",
            "Нет изоляции",
            "Без пленки"
          ]
        }
      },
      {
        "id": "d_glazing_door_material",
        "label": "Материал (Остекление: Дверь)",
        "items": [
          {
            "value": "Дерево"
          },
          {
            "value": "Металл"
          },
          {
            "value": "Пластик"
          },
          {
            "value": "Стекло"
          }
        ],
        "dict_type": "Материал",
        "tail_id": "d_common_tail",
        "ordering": {
          "mode": "alpha_auto",
          "special_first_values": [
            "Нет повреждений",
            "Нет утеплителя",
            "Нет изоляции",
            "Без пленки"
          ]
        }
      },
      {
        "id": "d_building_facade_subelement",
        "label": "Подэлемент (Фасад)",
        "items": [
          {
            "value": "Вентилируемый фасад"
          },
          {
            "value": "Обшивка"
          },
          {
            "value": "Облицовка"
          }
        ],
        "dict_type": "Подэлемент",
        "tail_id": "d_common_tail",
        "ordering": {
          "mode": "alpha_auto",
          "special_first_values": [
            "Нет повреждений",
            "Нет утеплителя",
            "Нет изоляции",
            "Без пленки"
          ]
        }
      },
      {
        "id": "d_facade_vent_cladding",
        "label": "Облицовка (Вентилируемый фасад)",
        "items": [
          {
            "value": "Керамогранит"
          },
          {
            "value": "Клинкерная плитка"
          },
          {
            "value": "Металлокассеты"
          },
          {
            "value": "Рейки"
          },
          {
            "value": "Фиброцемент"
          },
          {
            "value": "Нет повреждений"
          }
        ],
        "dict_type": "Облицовка",
        "tail_id": "d_common_tail",
        "ordering": {
          "mode": "alpha_auto",
          "special_first_values": [
            "Нет повреждений",
            "Нет утеплителя",
            "Нет изоляции",
            "Без пленки"
          ]
        }
      },
      {
        "id": "d_facade_vent_frame",
        "label": "Каркас (Вентилируемый фасад)",
        "items": [
          {
            "value": "Дерево"
          },
          {
            "value": "Комбинированный"
          },
          {
            "value": "Металл"
          },
          {
            "value": "Нет повреждений"
          }
        ],
        "dict_type": "Каркас",
        "tail_id": "d_common_tail",
        "ordering": {
          "mode": "alpha_auto",
          "special_first_values": [
            "Нет повреждений",
            "Нет утеплителя",
            "Нет изоляции",
            "Без пленки"
          ]
        }
      },
      {
        "id": "d_facade_vent_insulation",
        "label": "Утеплитель (Вентилируемый фасад)",
        "items": [
          {
            "value": "Минеральная вата"
          },
          {
            "value": "Пенополиуретан (ППУ)"
          },
          {
            "value": "Экструзионный пенополистирол (ЭППС)"
          },
          {
            "value": "Керамзит"
          },
          {
            "value": "Нет утеплителя"
          },
          {
            "value": "Нет повреждений"
          }
        ],
        "dict_type": "Утеплитель",
        "tail_id": "d_common_tail",
        "ordering": {
          "mode": "alpha_auto",
          "special_first_values": [
            "Нет повреждений",
            "Нет утеплителя",
            "Нет изоляции",
            "Без пленки"
          ]
        }
      },
      {
        "id": "d_facade_sheathing_view",
        "label": "Вид (Фасад: Обшивка)",
        "items": [
          {
            "value": "Вагонка"
          },
          {
            "value": "Тес"
          },
          {
            "value": "Имитация бруса"
          },
          {
            "value": "Термодревисина"
          },
          {
            "value": "Сайдинг"
          }
        ],
        "dict_type": "Вид",
        "tail_id": "d_common_tail",
        "ordering": {
          "mode": "alpha_auto",
          "special_first_values": [
            "Нет повреждений",
            "Нет утеплителя",
            "Нет изоляции",
            "Без пленки"
          ]
        }
      },
      {
        "id": "d_facade_sheathing_vagonka_material",
        "label": "Материал (Фасад: Обшивка: Вагонка)",
        "items": [
          {
            "value": "Дуб"
          },
          {
            "value": "Ель"
          },
          {
            "value": "Сосна"
          },
          {
            "value": "Ясень"
          }
        ],
        "dict_type": "Материал",
        "tail_id": "d_common_tail",
        "ordering": {
          "mode": "alpha_auto",
          "special_first_values": [
            "Нет повреждений",
            "Нет утеплителя",
            "Нет изоляции",
            "Без пленки"
          ]
        }
      },
      {
        "id": "d_facade_sheathing_tes_material",
        "label": "Материал (Фасад: Обшивка: Тес)",
        "items": [
          {
            "value": "Сосна"
          },
          {
            "value": "Ясень"
          },
          {
            "value": "Лиственница"
          }
        ],
        "dict_type": "Материал",
        "tail_id": "d_common_tail",
        "ordering": {
          "mode": "alpha_auto",
          "special_first_values": [
            "Нет повреждений",
            "Нет утеплителя",
            "Нет изоляции",
            "Без пленки"
          ]
        }
      },
      {
        "id": "d_facade_sheathing_thermo_material",
        "label": "Материал (Фасад: Обшивка: Термодревисина)",
        "items": [
          {
            "value": "Сосна"
          },
          {
            "value": "Ясень"
          },
          {
            "value": "Дуб"
          }
        ],
        "dict_type": "Материал",
        "tail_id": "d_common_tail",
        "ordering": {
          "mode": "alpha_auto",
          "special_first_values": [
            "Нет повреждений",
            "Нет утеплителя",
            "Нет изоляции",
            "Без пленки"
          ]
        }
      },
      {
        "id": "d_facade_siding_type",
        "label": "Тип (Фасад: Обшивка: Сайдинг)",
        "items": [
          {
            "value": "Акриловый"
          },
          {
            "value": "Виниловый"
          },
          {
            "value": "Металлический"
          },
          {
            "value": "Фиброцементный"
          }
        ],
        "dict_type": "Тип",
        "tail_id": "d_common_tail",
        "ordering": {
          "mode": "alpha_auto",
          "special_first_values": [
            "Нет повреждений",
            "Нет утеплителя",
            "Нет изоляции",
            "Без пленки"
          ]
        }
      },
      {
        "id": "d_facade_cladding_material",
        "label": "Материал (Фасад: Облицовка)",
        "items": [
          {
            "value": "Декоративный камень"
          },
          {
            "value": "Кирпич"
          },
          {
            "value": "Фасадная плитка"
          },
          {
            "value": "Декоративная штукатурка"
          },
          {
            "value": "Лакокрасочное покрытие"
          },
          {
            "value": "Побелка"
          }
        ],
        "dict_type": "Материал",
        "tail_id": "d_common_tail",
        "ordering": {
          "mode": "alpha_auto",
          "special_first_values": [
            "Нет повреждений",
            "Нет утеплителя",
            "Нет изоляции",
            "Без пленки"
          ]
        }
      },
      {
        "id": "d_facade_tile_type",
        "label": "Тип (Фасадная плитка)",
        "items": [
          {
            "value": "Агломерат"
          },
          {
            "value": "Бетонная"
          },
          {
            "value": "Керамическая"
          },
          {
            "value": "Керамогранит"
          },
          {
            "value": "Клинкерная"
          },
          {
            "value": "Терракотовая"
          }
        ],
        "dict_type": "Тип",
        "tail_id": "d_common_tail",
        "ordering": {
          "mode": "alpha_auto",
          "special_first_values": [
            "Нет повреждений",
            "Нет утеплителя",
            "Нет изоляции",
            "Без пленки"
          ]
        }
      },
      {
        "id": "d_facade_plaster_type",
        "label": "Тип (Декоративная штукатурка: фасад)",
        "items": [
          {
            "value": "Акриловая"
          },
          {
            "value": "Минеральная"
          },
          {
            "value": "Силикатная"
          },
          {
            "value": "Силиконовая"
          }
        ],
        "dict_type": "Тип",
        "tail_id": "d_common_tail",
        "ordering": {
          "mode": "alpha_auto",
          "special_first_values": [
            "Нет повреждений",
            "Нет утеплителя",
            "Нет изоляции",
            "Без пленки"
          ]
        }
      },
      {
        "id": "d_facade_paint_type",
        "label": "Тип (Лакокрасочное покрытие: фасад)",
        "items": [
          {
            "value": "Акриловое"
          },
          {
            "value": "Водоэмульсионное"
          },
          {
            "value": "Силикатное"
          },
          {
            "value": "Известковое"
          }
        ],
        "dict_type": "Тип",
        "tail_id": "d_common_tail",
        "ordering": {
          "mode": "alpha_auto",
          "special_first_values": [
            "Нет повреждений",
            "Нет утеплителя",
            "Нет изоляции",
            "Без пленки"
          ]
        }
      },
      {
        "id": "d_facade_whitewash_type",
        "label": "Тип (Побелка: фасад)",
        "items": [
          {
            "value": "Водоэмульсионная"
          },
          {
            "value": "Известковая"
          },
          {
            "value": "Меловая"
          }
        ],
        "dict_type": "Тип",
        "tail_id": "d_common_tail",
        "ordering": {
          "mode": "alpha_auto",
          "special_first_values": [
            "Нет повреждений",
            "Нет утеплителя",
            "Нет изоляции",
            "Без пленки"
          ]
        }
      },
      {
        "id": "d_building_roof_subelement",
        "label": "Подэлемент (Крыша)",
        "items": [
          {
            "value": "Кровля"
          },
          {
            "value": "Водосточная система"
          },
          {
            "value": "Снегозадержатели"
          }
        ],
        "dict_type": "Подэлемент",
        "tail_id": "d_common_tail",
        "ordering": {
          "mode": "alpha_auto",
          "special_first_values": [
            "Нет повреждений",
            "Нет утеплителя",
            "Нет изоляции",
            "Без пленки"
          ]
        }
      },
      {
        "id": "d_roof_view",
        "label": "Вид (Кровля)",
        "items": [
          {
            "value": "Двухскатная"
          },
          {
            "value": "Мансардная"
          },
          {
            "value": "Вальмовая"
          },
          {
            "value": "Плоская"
          }
        ],
        "dict_type": "Вид",
        "tail_id": "d_common_tail",
        "ordering": {
          "mode": "alpha_auto",
          "special_first_values": [
            "Нет повреждений",
            "Нет утеплителя",
            "Нет изоляции",
            "Без пленки"
          ]
        }
      },
      {
        "id": "d_roof_covering",
        "label": "Покрытие (Кровля)",
        "items": [
          {
            "value": "Мягкая кровля"
          },
          {
            "value": "Металлочерепица"
          },
          {
            "value": "Шифер"
          },
          {
            "value": "Профнастил"
          },
          {
            "value": "Нет повреждений"
          }
        ],
        "dict_type": "Покрытие",
        "tail_id": "d_common_tail",
        "ordering": {
          "mode": "alpha_auto",
          "special_first_values": [
            "Нет повреждений",
            "Нет утеплителя",
            "Нет изоляции",
            "Без пленки"
          ]
        }
      },
      {
        "id": "d_roof_hydro",
        "label": "Гидро/Пароизоляция (Кровля)",
        "items": [
          {
            "value": "Мембрана"
          },
          {
            "value": "Пленка"
          },
          {
            "value": "Рубероид"
          },
          {
            "value": "Нет изоляции"
          },
          {
            "value": "Нет повреждений"
          }
        ],
        "ordering": {
          "mode": "alpha_auto",
          "special_first_values": [
            "Нет повреждений",
            "Нет утеплителя",
            "Нет изоляции",
            "Без пленки"
          ]
        }
      },
      {
        "id": "d_roof_insulation",
        "label": "Утеплитель (Кровля)",
        "items": [
          {
            "value": "Минеральная вата"
          },
          {
            "value": "Пенополиуретан (ППУ)"
          },
          {
            "value": "Экструзионный пенополистирол (ЭППС)"
          },
          {
            "value": "Керамзит"
          },
          {
            "value": "Нет утеплителя"
          },
          {
            "value": "Нет повреждений"
          }
        ],
        "dict_type": "Утеплитель",
        "tail_id": "d_common_tail",
        "ordering": {
          "mode": "alpha_auto",
          "special_first_values": [
            "Нет повреждений",
            "Нет утеплителя",
            "Нет изоляции",
            "Без пленки"
          ]
        }
      },
      {
        "id": "d_roof_rafters_material",
        "label": "Материал (Стропильная система)",
        "items": [
          {
            "value": "Дерево"
          },
          {
            "value": "Металл"
          },
          {
            "value": "Нет повреждений"
          }
        ],
        "dict_type": "Материал",
        "tail_id": "d_common_tail",
        "ordering": {
          "mode": "alpha_auto",
          "special_first_values": [
            "Нет повреждений",
            "Нет утеплителя",
            "Нет изоляции",
            "Без пленки"
          ]
        }
      },
      {
        "id": "d_gutter_material",
        "label": "Материал (Водосточная система)",
        "items": [
          {
            "value": "Металл"
          },
          {
            "value": "Пластик"
          }
        ],
        "dict_type": "Материал",
        "tail_id": "d_common_tail",
        "ordering": {
          "mode": "alpha_auto",
          "special_first_values": [
            "Нет повреждений",
            "Нет утеплителя",
            "Нет изоляции",
            "Без пленки"
          ]
        }
      },
      {
        "id": "d_snowguards_type",
        "label": "Тип (Снегозадержатели)",
        "items": [
          {
            "value": "Нет снегодержателей"
          },
          {
            "value": "Трубчатые"
          },
          {
            "value": "Решетчатые"
          },
          {
            "value": "Уголковые"
          },
          {
            "value": "Бугельные"
          }
        ],
        "dict_type": "Тип",
        "tail_id": "d_common_tail",
        "ordering": {
          "mode": "alpha_auto",
          "special_first_values": [
            "Нет повреждений",
            "Нет утеплителя",
            "Нет изоляции",
            "Без пленки"
          ]
        }
      },
      {
        "id": "d_building_arch_subelement",
        "label": "Подэлемент (Архитектурные элементы)",
        "items": [
          {
            "value": "Карнизы"
          },
          {
            "value": "Наличники"
          },
          {
            "value": "Решетки"
          },
          {
            "value": "Ставни"
          }
        ],
        "dict_type": "Подэлемент",
        "tail_id": "d_common_tail",
        "ordering": {
          "mode": "alpha_auto",
          "special_first_values": [
            "Нет повреждений",
            "Нет утеплителя",
            "Нет изоляции",
            "Без пленки"
          ]
        }
      },
      {
        "id": "d_arch_cornice_material",
        "label": "Материал (Карнизы)",
        "items": [
          {
            "value": "Бетон"
          },
          {
            "value": "Пенопласт"
          },
          {
            "value": "Полиуретан"
          },
          {
            "value": "ЭППС"
          }
        ],
        "dict_type": "Материал",
        "tail_id": "d_common_tail",
        "ordering": {
          "mode": "alpha_auto",
          "special_first_values": [
            "Нет повреждений",
            "Нет утеплителя",
            "Нет изоляции",
            "Без пленки"
          ]
        }
      },
      {
        "id": "d_arch_platband_material",
        "label": "Материал (Наличники)",
        "items": [
          {
            "value": "Бетон"
          },
          {
            "value": "Дерево"
          },
          {
            "value": "Камень"
          },
          {
            "value": "Металл"
          },
          {
            "value": "Пластик"
          }
        ],
        "dict_type": "Материал",
        "tail_id": "d_common_tail",
        "ordering": {
          "mode": "alpha_auto",
          "special_first_values": [
            "Нет повреждений",
            "Нет утеплителя",
            "Нет изоляции",
            "Без пленки"
          ]
        }
      },
      {
        "id": "d_arch_grille_view",
        "label": "Вид (Решетки)",
        "items": [
          {
            "value": "Вентиляционные"
          },
          {
            "value": "Декоративные"
          },
          {
            "value": "Оконные"
          }
        ],
        "dict_type": "Вид",
        "tail_id": "d_common_tail",
        "ordering": {
          "mode": "alpha_auto",
          "special_first_values": [
            "Нет повреждений",
            "Нет утеплителя",
            "Нет изоляции",
            "Без пленки"
          ]
        }
      },
      {
        "id": "d_arch_shutter_view",
        "label": "Вид (Ставни)",
        "items": [
          {
            "value": "Глухие"
          },
          {
            "value": "Сквозные"
          },
          {
            "value": "Складные"
          }
        ],
        "dict_type": "Вид",
        "tail_id": "d_common_tail",
        "ordering": {
          "mode": "alpha_auto",
          "special_first_values": [
            "Нет повреждений",
            "Нет утеплителя",
            "Нет изоляции",
            "Без пленки"
          ]
        }
      },
      {
        "id": "d_building_construct_subelement",
        "label": "Подэлемент (Конструктивные элементы)",
        "items": [
          {
            "value": "Стены"
          },
          {
            "value": "Перекрытия"
          },
          {
            "value": "Ступени"
          },
          {
            "value": "Фундамент"
          },
          {
            "value": "Цоколь"
          }
        ],
        "dict_type": "Подэлемент",
        "tail_id": "d_common_tail",
        "ordering": {
          "mode": "alpha_auto",
          "special_first_values": [
            "Нет повреждений",
            "Нет утеплителя",
            "Нет изоляции",
            "Без пленки"
          ]
        }
      },
      {
        "id": "d_construct_walls_material",
        "label": "Материал (Конструктив: Стены)",
        "items": [
          {
            "value": "Газоблок"
          },
          {
            "value": "Пеноблок"
          },
          {
            "value": "Бревно"
          },
          {
            "value": "Брус"
          },
          {
            "value": "Каркас"
          },
          {
            "value": "Кирпич"
          },
          {
            "value": "Монолит"
          },
          {
            "value": "Панели ЖБ"
          }
        ],
        "dict_type": "Материал",
        "tail_id": "d_common_tail",
        "ordering": {
          "mode": "alpha_auto",
          "special_first_values": [
            "Нет повреждений",
            "Нет утеплителя",
            "Нет изоляции",
            "Без пленки"
          ]
        }
      },
      {
        "id": "d_construct_floors_material",
        "label": "Материал (Конструктив: Перекрытия)",
        "items": [
          {
            "value": "Деревянные балки"
          },
          {
            "value": "ЖБ плита"
          },
          {
            "value": "Монолит"
          },
          {
            "value": "Смешанное"
          }
        ],
        "dict_type": "Материал",
        "tail_id": "d_common_tail",
        "ordering": {
          "mode": "alpha_auto",
          "special_first_values": [
            "Нет повреждений",
            "Нет утеплителя",
            "Нет изоляции",
            "Без пленки"
          ]
        }
      },
      {
        "id": "d_construct_steps_material",
        "label": "Материал (Конструктив: Ступени)",
        "items": [
          {
            "value": "Бетон"
          },
          {
            "value": "Дерево"
          },
          {
            "value": "Камень"
          },
          {
            "value": "Металл"
          }
        ],
        "dict_type": "Материал",
        "tail_id": "d_common_tail",
        "ordering": {
          "mode": "alpha_auto",
          "special_first_values": [
            "Нет повреждений",
            "Нет утеплителя",
            "Нет изоляции",
            "Без пленки"
          ]
        }
      },
      {
        "id": "d_construct_foundation_type",
        "label": "Тип (Конструктив: Фундамент)",
        "items": [
          {
            "value": "Ленточный"
          },
          {
            "value": "Плита"
          },
          {
            "value": "Свайный"
          },
          {
            "value": "Блочный"
          }
        ],
        "dict_type": "Тип",
        "tail_id": "d_common_tail",
        "ordering": {
          "mode": "alpha_auto",
          "special_first_values": [
            "Нет повреждений",
            "Нет утеплителя",
            "Нет изоляции",
            "Без пленки"
          ]
        }
      },
      {
        "id": "d_construct_socle_finish",
        "label": "Отделка (Конструктив: Цоколь)",
        "items": [
          {
            "value": "Бетон"
          },
          {
            "value": "Камень"
          },
          {
            "value": "Кирпич"
          },
          {
            "value": "Панели"
          },
          {
            "value": "Штукатурка"
          }
        ],
        "ordering": {
          "mode": "alpha_auto",
          "special_first_values": [
            "Нет повреждений",
            "Нет утеплителя",
            "Нет изоляции",
            "Без пленки"
          ]
        }
      }
    ],
    "fields": [
      {
        "id": "f_insurer",
        "label": "Страхователь",
        "type": "text",
        "required": true
      },
      {
        "id": "f_insurer_rep",
        "label": "Представитель страхователя (ФИО)",
        "type": "text",
        "required": true
      },
      {
        "id": "f_policy_number",
        "label": "Номер договора страхования",
        "type": "text",
        "required": true
      },
      {
        "id": "f_policy_date",
        "label": "Дата заключения договора страхования",
        "type": "date",
        "required": true
      },
      {
        "id": "f_inspection_address",
        "label": "Адрес места осмотра",
        "type": "text",
        "required": true
      },
      {
        "id": "f_event_circumstances",
        "label": "Описание события и причины",
        "type": "textarea",
        "required": true
      },
      {
        "id": "f_event_date",
        "label": "Дата события",
        "type": "date",
        "required": true
      },
      {
        "id": "f_inspection_date",
        "label": "Дата осмотра",
        "type": "date",
        "required": true
      },
      {
        "id": "f_damage_category",
        "label": "Категория",
        "type": "select",
        "required": true,
        "dictionary_id": "d_category"
      },
      {
        "id": "f_damage_element",
        "label": "Элемент",
        "type": "select",
        "required": true,
        "allow_other_choice": true,
        "other_choice_value": "Иное",
        "other_value_mode": "inline",
        "value_storage": "choice_or_other_object",
        "other_object_keys": {
          "choice": "choice",
          "other": "other"
        }
      },
      {
        "id": "f_damage_subelement",
        "label": "Подэлемент",
        "type": "select",
        "required": false,
        "allow_other_choice": true,
        "other_choice_value": "Иное",
        "other_value_mode": "inline",
        "value_storage": "choice_or_other_object",
        "other_object_keys": {
          "choice": "choice",
          "other": "other"
        }
      },
      {
        "id": "f_material",
        "label": "Материал",
        "type": "select",
        "required": true,
        "allow_other_choice": true,
        "other_choice_value": "Иное",
        "other_value_mode": "inline",
        "value_storage": "choice_or_other_object",
        "other_object_keys": {
          "choice": "choice",
          "other": "other"
        }
      },
      {
        "id": "f_view",
        "label": "Вид",
        "type": "select",
        "required": true,
        "allow_other_choice": true,
        "other_choice_value": "Иное",
        "other_value_mode": "inline",
        "value_storage": "choice_or_other_object",
        "other_object_keys": {
          "choice": "choice",
          "other": "other"
        }
      },
      {
        "id": "f_type",
        "label": "Тип",
        "type": "select",
        "required": true,
        "allow_other_choice": true,
        "other_choice_value": "Иное",
        "other_value_mode": "inline",
        "value_storage": "choice_or_other_object",
        "other_object_keys": {
          "choice": "choice",
          "other": "other"
        }
      },
      {
        "id": "f_texture",
        "label": "Фактура",
        "type": "select",
        "required": true,
        "allow_other_choice": true,
        "other_choice_value": "Иное",
        "other_value_mode": "inline",
        "value_storage": "choice_or_other_object",
        "other_object_keys": {
          "choice": "choice",
          "other": "other"
        }
      },
      {
        "id": "f_details",
        "label": "Детализация",
        "type": "select",
        "required": true,
        "allow_other_choice": true,
        "other_choice_value": "Иное",
        "other_value_mode": "inline",
        "value_storage": "choice_or_other_object",
        "other_object_keys": {
          "choice": "choice",
          "other": "other"
        }
      },
      {
        "id": "f_laminate_class",
        "label": "Класс ламината",
        "type": "select",
        "required": true,
        "dictionary_id": "d_laminate_class",
        "allow_other_choice": true,
        "other_choice_value": "Иное",
        "other_value_mode": "inline",
        "value_storage": "choice_or_other_object",
        "other_object_keys": {
          "choice": "choice",
          "other": "other"
        }
      },
      {
        "id": "f_window_material",
        "label": "Материал (окно)",
        "type": "select",
        "required": true,
        "allow_other_choice": true,
        "other_choice_value": "Иное",
        "other_value_mode": "inline",
        "value_storage": "choice_or_other_object",
        "other_object_keys": {
          "choice": "choice",
          "other": "other"
        }
      },
      {
        "id": "f_window_type",
        "label": "Тип окна",
        "type": "select",
        "required": true,
        "dictionary_id": "d_window_type",
        "allow_other_choice": true,
        "other_choice_value": "Иное",
        "other_value_mode": "inline",
        "value_storage": "choice_or_other_object",
        "other_object_keys": {
          "choice": "choice",
          "other": "other"
        }
      },
      {
        "id": "f_window_size",
        "label": "Размер окна",
        "type": "group_xy",
        "required": true,
        "axis_labels": {
          "x": "Высота",
          "y": "Ширина"
        },
        "unit_options_dictionary_id": "d_unit_cm_m"
      },
      {
        "id": "f_door_material",
        "label": "Материал (дверь)",
        "type": "select",
        "required": true,
        "allow_other_choice": true,
        "other_choice_value": "Иное",
        "other_value_mode": "inline",
        "value_storage": "choice_or_other_object",
        "other_object_keys": {
          "choice": "choice",
          "other": "other"
        }
      },
      {
        "id": "f_door_type",
        "label": "Тип двери",
        "type": "select",
        "required": true,
        "dictionary_id": "d_door_type",
        "allow_other_choice": true,
        "other_choice_value": "Иное",
        "other_value_mode": "inline",
        "value_storage": "choice_or_other_object",
        "other_object_keys": {
          "choice": "choice",
          "other": "other"
        }
      },
      {
        "id": "f_door_size",
        "label": "Размер двери",
        "type": "group_xy",
        "required": true,
        "axis_labels": {
          "x": "Высота",
          "y": "Ширина"
        },
        "unit_options_dictionary_id": "d_unit_cm_m"
      },
      {
        "id": "f_glass_type",
        "label": "Тип стекла",
        "type": "select",
        "required": true,
        "allow_other_choice": true,
        "other_choice_value": "Иное",
        "other_value_mode": "inline",
        "value_storage": "choice_or_other_object",
        "other_object_keys": {
          "choice": "choice",
          "other": "other"
        }
      },
      {
        "id": "f_cameras",
        "label": "Кол-во камер",
        "type": "select",
        "required": true,
        "dictionary_id": "d_cameras",
        "allow_other_choice": true,
        "other_choice_value": "Иное",
        "other_value_mode": "inline",
        "value_storage": "choice_or_other_object",
        "other_object_keys": {
          "choice": "choice",
          "other": "other"
        }
      },
      {
        "id": "f_film_type",
        "label": "Вид пленки",
        "type": "select",
        "required": true,
        "dictionary_id": "d_film_type"
      },
      {
        "id": "f_glasspack_size",
        "label": "Размер стеклопакета",
        "type": "group_xy",
        "required": true,
        "axis_labels": {
          "x": "Высота",
          "y": "Ширина"
        },
        "unit_options_dictionary_id": "d_unit_cm_m"
      },
      {
        "id": "f_glass_thickness_mm",
        "label": "Толщина стекла (мм)",
        "type": "number",
        "required": true
      },
      {
        "id": "f_glass_formula",
        "label": "Формула стекла",
        "type": "text",
        "required": false
      },
      {
        "id": "f_damage_char",
        "label": "Характер повреждения",
        "type": "select",
        "required": true,
        "allow_other_choice": true,
        "other_choice_value": "Иное",
        "other_value_mode": "inline",
        "value_storage": "choice_or_other_object",
        "other_object_keys": {
          "choice": "choice",
          "other": "other"
        }
      },
      {
        "id": "f_damage_size",
        "label": "Размер повреждения",
        "type": "group_xy",
        "required": true,
        "axis_labels": {
          "x": "Длина",
          "y": "Ширина"
        },
        "unit_options_dictionary_id": "d_unit_cm_m"
      },
      {
        "id": "f_room_size",
        "label": "Размер помещения",
        "type": "group_xyz",
        "required": true,
        "axis_labels": {
          "x": "Длина",
          "y": "Ширина",
          "z": "Высота"
        },
        "unit_static": "м"
      },
      {
        "id": "f_year_last_caprepair",
        "label": "Год последнего капремонта",
        "type": "number",
        "required": true,
        "integer": true
      },
      {
        "id": "f_door_openings_count",
        "label": "Кол-во дверных проемов",
        "type": "number",
        "required": true,
        "min": 0,
        "integer": true
      },
      {
        "id": "f_window_openings_count",
        "label": "Кол-во оконных проемов",
        "type": "number",
        "required": true,
        "min": 0,
        "integer": true
      },
      {
        "id": "f_year_built",
        "label": "Год постройки здания",
        "type": "number",
        "required": true,
        "integer": true
      },
      {
        "id": "f_photos",
        "label": "Фотофиксация",
        "type": "photos",
        "required": true,
        "max_count": 10
      },
      {
        "id": "f_facade_cladding",
        "label": "Облицовка",
        "type": "select",
        "required": true,
        "dictionary_id": "d_facade_vent_cladding",
        "allow_other_choice": true,
        "other_choice_value": "Иное",
        "other_value_mode": "inline",
        "value_storage": "choice_or_other_object",
        "other_object_keys": {
          "choice": "choice",
          "other": "other"
        }
      },
      {
        "id": "f_facade_frame",
        "label": "Каркас",
        "type": "select",
        "required": true,
        "dictionary_id": "d_facade_vent_frame",
        "allow_other_choice": true,
        "other_choice_value": "Иное",
        "other_value_mode": "inline",
        "value_storage": "choice_or_other_object",
        "other_object_keys": {
          "choice": "choice",
          "other": "other"
        }
      },
      {
        "id": "f_facade_insulation",
        "label": "Утеплитель",
        "type": "select",
        "required": true,
        "dictionary_id": "d_facade_vent_insulation",
        "allow_other_choice": true,
        "other_choice_value": "Иное",
        "other_value_mode": "inline",
        "value_storage": "choice_or_other_object",
        "other_object_keys": {
          "choice": "choice",
          "other": "other"
        }
      },
      {
        "id": "f_roof_view",
        "label": "Вид",
        "type": "select",
        "required": true,
        "dictionary_id": "d_roof_view",
        "allow_other_choice": true,
        "other_choice_value": "Иное",
        "other_value_mode": "inline",
        "value_storage": "choice_or_other_object",
        "other_object_keys": {
          "choice": "choice",
          "other": "other"
        }
      },
      {
        "id": "f_roof_covering",
        "label": "Покрытие",
        "type": "select",
        "required": true,
        "dictionary_id": "d_roof_covering",
        "allow_other_choice": true,
        "other_choice_value": "Иное",
        "other_value_mode": "inline",
        "value_storage": "choice_or_other_object",
        "other_object_keys": {
          "choice": "choice",
          "other": "other"
        }
      },
      {
        "id": "f_roof_hydro",
        "label": "Гидро/Пароизоляция",
        "type": "select",
        "required": true,
        "dictionary_id": "d_roof_hydro"
      },
      {
        "id": "f_roof_insulation",
        "label": "Утеплитель",
        "type": "select",
        "required": true,
        "dictionary_id": "d_roof_insulation",
        "allow_other_choice": true,
        "other_choice_value": "Иное",
        "other_value_mode": "inline",
        "value_storage": "choice_or_other_object",
        "other_object_keys": {
          "choice": "choice",
          "other": "other"
        }
      },
      {
        "id": "f_roof_rafters_material",
        "label": "Стропильная система",
        "type": "select",
        "required": true,
        "dictionary_id": "d_roof_rafters_material",
        "allow_other_choice": true,
        "other_choice_value": "Иное",
        "other_value_mode": "inline",
        "value_storage": "choice_or_other_object",
        "other_object_keys": {
          "choice": "choice",
          "other": "other"
        }
      },
      {
        "id": "f_gutter_material",
        "label": "Материал",
        "type": "select",
        "required": true,
        "dictionary_id": "d_gutter_material",
        "allow_other_choice": true,
        "other_choice_value": "Иное",
        "other_value_mode": "inline",
        "value_storage": "choice_or_other_object",
        "other_object_keys": {
          "choice": "choice",
          "other": "other"
        }
      },
      {
        "id": "f_snowguards_type",
        "label": "Тип",
        "type": "select",
        "required": true,
        "dictionary_id": "d_snowguards_type",
        "allow_other_choice": true,
        "other_choice_value": "Иное",
        "other_value_mode": "inline",
        "value_storage": "choice_or_other_object",
        "other_object_keys": {
          "choice": "choice",
          "other": "other"
        }
      },
      {
        "id": "f_furniture_name",
        "label": "Наименование",
        "type": "text",
        "required": true
      },
      {
        "id": "f_furniture_brand",
        "label": "Марка",
        "type": "text",
        "required": false
      },
      {
        "id": "f_furniture_year",
        "label": "Год выпуска",
        "type": "number",
        "required": false,
        "integer": true
      },
      {
        "id": "f_furniture_info",
        "label": "Доп. информация",
        "type": "textarea",
        "required": false
      },
      {
        "id": "f_socle_finish",
        "label": "Отделка",
        "type": "select",
        "required": true,
        "dictionary_id": "d_construct_socle_finish"
      }
    ],
    "inventory": {
      "damage_item": {
        "selectors": {
          "category": {
            "field_id": "f_damage_category",
            "dictionary_id": "d_category"
          },
          "element": {
            "field_id": "f_damage_element",
            "dictionary_by_category": {
              "Помещение": "d_element_room",
              "Здание": "d_element_building",
              "Остекление": "d_element_glazing"
            },
            "allow_other_choice": true
          },
          "subelement": {
            "field_id": "f_damage_subelement",
            "dictionary_by_category_element": {
              "Помещение|Потолок": "d_room_ceiling_subelement",
              "Помещение|Стена": "d_room_wall_subelement",
              "Помещение|Пол": "d_room_floor_subelement",
              "Здание|Фасад": "d_building_facade_subelement",
              "Здание|Крыша": "d_building_roof_subelement",
              "Здание|Архитектурные элементы": "d_building_arch_subelement",
              "Здание|Конструктивные элементы": "d_building_construct_subelement"
            },
            "allow_other_choice": true
          }
        },
        "templates": [
          {
            "id": "t_room_ceiling__",
            "when": {
              "category": "Помещение",
              "element": "Потолок",
              "subelement": "Армстронг"
            },
            "fields": [
              {
                "field_id": "f_damage_subelement",
                "dictionary_id": "d_room_ceiling_subelement",
                "required": true
              },
              {
                "field_id": "f_material",
                "dictionary_id": "d_ceiling_armstrong_material",
                "required": true
              },
              {
                "field_id": "f_damage_char",
                "dictionary_id": "d_damage_char_common",
                "required": true
              },
              {
                "field_id": "f_damage_size",
                "required": true
              },
              {
                "field_id": "f_room_size",
                "required": true
              },
              {
                "field_id": "f_year_last_caprepair",
                "required": true
              },
              {
                "field_id": "f_photos",
                "required": true
              }
            ]
          },
          {
            "id": "t_room_ceiling__",
            "when": {
              "category": "Помещение",
              "element": "Потолок",
              "subelement": "Вагонка"
            },
            "fields": [
              {
                "field_id": "f_damage_subelement",
                "dictionary_id": "d_room_ceiling_subelement",
                "required": true
              },
              {
                "field_id": "f_material",
                "dictionary_id": "d_wood_species",
                "required": true
              },
              {
                "field_id": "f_damage_char",
                "dictionary_id": "d_damage_char_common",
                "required": true
              },
              {
                "field_id": "f_damage_size",
                "required": true
              },
              {
                "field_id": "f_room_size",
                "required": true
              },
              {
                "field_id": "f_year_last_caprepair",
                "required": true
              },
              {
                "field_id": "f_photos",
                "required": true
              }
            ]
          },
          {
            "id": "t_room_ceiling__",
            "when": {
              "category": "Помещение",
              "element": "Потолок",
              "subelement": "Декоративная штукатурка"
            },
            "fields": [
              {
                "field_id": "f_damage_subelement",
                "dictionary_id": "d_room_ceiling_subelement",
                "required": true
              },
              {
                "field_id": "f_view",
                "dictionary_id": "d_ceiling_decorplaster_view",
                "required": true
              },
              {
                "field_id": "f_damage_char",
                "dictionary_id": "d_damage_char_common",
                "required": true
              },
              {
                "field_id": "f_damage_size",
                "required": true
              },
              {
                "field_id": "f_room_size",
                "required": true
              },
              {
                "field_id": "f_year_last_caprepair",
                "required": true
              },
              {
                "field_id": "f_photos",
                "required": true
              }
            ]
          },
          {
            "id": "t_room_ceiling__",
            "when": {
              "category": "Помещение",
              "element": "Потолок",
              "subelement": "Кассетный потолок"
            },
            "fields": [
              {
                "field_id": "f_damage_subelement",
                "dictionary_id": "d_room_ceiling_subelement",
                "required": true
              },
              {
                "field_id": "f_material",
                "dictionary_id": "d_ceiling_cassette_material",
                "required": true
              },
              {
                "field_id": "f_damage_char",
                "dictionary_id": "d_damage_char_common",
                "required": true
              },
              {
                "field_id": "f_damage_size",
                "required": true
              },
              {
                "field_id": "f_room_size",
                "required": true
              },
              {
                "field_id": "f_year_last_caprepair",
                "required": true
              },
              {
                "field_id": "f_photos",
                "required": true
              }
            ]
          },
          {
            "id": "t_room_ceiling__",
            "when": {
              "category": "Помещение",
              "element": "Потолок",
              "subelement": "Лакокрасочное покрытие"
            },
            "fields": [
              {
                "field_id": "f_damage_subelement",
                "dictionary_id": "d_room_ceiling_subelement",
                "required": true
              },
              {
                "field_id": "f_view",
                "dictionary_id": "d_ceiling_paint_view",
                "required": true
              },
              {
                "field_id": "f_damage_char",
                "dictionary_id": "d_damage_char_common",
                "required": true
              },
              {
                "field_id": "f_damage_size",
                "required": true
              },
              {
                "field_id": "f_room_size",
                "required": true
              },
              {
                "field_id": "f_year_last_caprepair",
                "required": true
              },
              {
                "field_id": "f_photos",
                "required": true
              }
            ]
          },
          {
            "id": "t_room_ceiling__",
            "when": {
              "category": "Помещение",
              "element": "Потолок",
              "subelement": "Натяжной потолок"
            },
            "fields": [
              {
                "field_id": "f_damage_subelement",
                "dictionary_id": "d_room_ceiling_subelement",
                "required": true
              },
              {
                "field_id": "f_view",
                "dictionary_id": "d_ceiling_stretch_view",
                "required": true
              },
              {
                "field_id": "f_texture",
                "dictionary_id": "d_ceiling_stretch_texture",
                "required": true
              },
              {
                "field_id": "f_damage_char",
                "dictionary_id": "d_damage_char_common",
                "required": true
              },
              {
                "field_id": "f_damage_size",
                "required": true
              },
              {
                "field_id": "f_room_size",
                "required": true
              },
              {
                "field_id": "f_year_last_caprepair",
                "required": true
              },
              {
                "field_id": "f_photos",
                "required": true
              }
            ]
          },
          {
            "id": "t_room_ceiling__",
            "when": {
              "category": "Помещение",
              "element": "Потолок",
              "subelement": "Обои"
            },
            "fields": [
              {
                "field_id": "f_damage_subelement",
                "dictionary_id": "d_room_ceiling_subelement",
                "required": true
              },
              {
                "field_id": "f_type",
                "dictionary_id": "d_ceiling_wallpaper_type",
                "required": true
              },
              {
                "field_id": "f_damage_char",
                "dictionary_id": "d_damage_char_common",
                "required": true
              },
              {
                "field_id": "f_damage_size",
                "required": true
              },
              {
                "field_id": "f_room_size",
                "required": true
              },
              {
                "field_id": "f_year_last_caprepair",
                "required": true
              },
              {
                "field_id": "f_photos",
                "required": true
              }
            ]
          },
          {
            "id": "t_room_ceiling__",
            "when": {
              "category": "Помещение",
              "element": "Потолок",
              "subelement": "Плинтус потолочный"
            },
            "fields": [
              {
                "field_id": "f_damage_subelement",
                "dictionary_id": "d_room_ceiling_subelement",
                "required": true
              },
              {
                "field_id": "f_material",
                "dictionary_id": "d_ceiling_plinth_material",
                "required": true
              },
              {
                "field_id": "f_damage_char",
                "dictionary_id": "d_damage_char_common",
                "required": true
              },
              {
                "field_id": "f_damage_size",
                "required": true
              },
              {
                "field_id": "f_room_size",
                "required": true
              },
              {
                "field_id": "f_year_last_caprepair",
                "required": true
              },
              {
                "field_id": "f_photos",
                "required": true
              }
            ]
          },
          {
            "id": "t_room_ceiling__",
            "when": {
              "category": "Помещение",
              "element": "Потолок",
              "subelement": "Побелка"
            },
            "fields": [
              {
                "field_id": "f_damage_subelement",
                "dictionary_id": "d_room_ceiling_subelement",
                "required": true
              },
              {
                "field_id": "f_view",
                "dictionary_id": "d_ceiling_whitewash_view",
                "required": true
              },
              {
                "field_id": "f_damage_char",
                "dictionary_id": "d_damage_char_common",
                "required": true
              },
              {
                "field_id": "f_damage_size",
                "required": true
              },
              {
                "field_id": "f_room_size",
                "required": true
              },
              {
                "field_id": "f_year_last_caprepair",
                "required": true
              },
              {
                "field_id": "f_photos",
                "required": true
              }
            ]
          },
          {
            "id": "t_room_ceiling__",
            "when": {
              "category": "Помещение",
              "element": "Потолок",
              "subelement": "Подвесной потолок"
            },
            "fields": [
              {
                "field_id": "f_damage_subelement",
                "dictionary_id": "d_room_ceiling_subelement",
                "required": true
              },
              {
                "field_id": "f_type",
                "dictionary_id": "d_ceiling_suspended_type",
                "required": true
              },
              {
                "field_id": "f_damage_char",
                "dictionary_id": "d_damage_char_common",
                "required": true
              },
              {
                "field_id": "f_damage_size",
                "required": true
              },
              {
                "field_id": "f_room_size",
                "required": true
              },
              {
                "field_id": "f_year_last_caprepair",
                "required": true
              },
              {
                "field_id": "f_photos",
                "required": true
              }
            ]
          },
          {
            "id": "t_room_ceiling__",
            "when": {
              "category": "Помещение",
              "element": "Потолок",
              "subelement": "Потолочная плитка"
            },
            "fields": [
              {
                "field_id": "f_damage_subelement",
                "dictionary_id": "d_room_ceiling_subelement",
                "required": true
              },
              {
                "field_id": "f_material",
                "dictionary_id": "d_ceiling_tile_material",
                "required": true
              },
              {
                "field_id": "f_damage_char",
                "dictionary_id": "d_damage_char_common",
                "required": true
              },
              {
                "field_id": "f_damage_size",
                "required": true
              },
              {
                "field_id": "f_room_size",
                "required": true
              },
              {
                "field_id": "f_year_last_caprepair",
                "required": true
              },
              {
                "field_id": "f_photos",
                "required": true
              }
            ]
          },
          {
            "id": "t_room_ceiling__",
            "when": {
              "category": "Помещение",
              "element": "Потолок",
              "subelement": "Реечный потолок"
            },
            "fields": [
              {
                "field_id": "f_damage_subelement",
                "dictionary_id": "d_room_ceiling_subelement",
                "required": true
              },
              {
                "field_id": "f_material",
                "dictionary_id": "d_ceiling_rack_material",
                "required": true
              },
              {
                "field_id": "f_damage_char",
                "dictionary_id": "d_damage_char_common",
                "required": true
              },
              {
                "field_id": "f_damage_size",
                "required": true
              },
              {
                "field_id": "f_room_size",
                "required": true
              },
              {
                "field_id": "f_year_last_caprepair",
                "required": true
              },
              {
                "field_id": "f_photos",
                "required": true
              }
            ]
          },
          {
            "id": "t_room_wall__",
            "when": {
              "category": "Помещение",
              "element": "Стена",
              "subelement": "Дверные откосы"
            },
            "fields": [
              {
                "field_id": "f_damage_subelement",
                "dictionary_id": "d_room_wall_subelement",
                "required": true
              },
              {
                "field_id": "f_material",
                "dictionary_id": "d_wall_slopes_material",
                "required": true
              },
              {
                "field_id": "f_damage_char",
                "dictionary_id": "d_damage_char_common",
                "required": true
              },
              {
                "field_id": "f_damage_size",
                "required": true
              },
              {
                "field_id": "f_room_size",
                "required": true
              },
              {
                "field_id": "f_year_last_caprepair",
                "required": true
              },
              {
                "field_id": "f_door_openings_count",
                "required": true
              },
              {
                "field_id": "f_window_openings_count",
                "required": true
              },
              {
                "field_id": "f_photos",
                "required": true
              }
            ]
          },
          {
            "id": "t_room_wall__",
            "when": {
              "category": "Помещение",
              "element": "Стена",
              "subelement": "Оконные откосы"
            },
            "fields": [
              {
                "field_id": "f_damage_subelement",
                "dictionary_id": "d_room_wall_subelement",
                "required": true
              },
              {
                "field_id": "f_material",
                "dictionary_id": "d_wall_slopes_material",
                "required": true
              },
              {
                "field_id": "f_damage_char",
                "dictionary_id": "d_damage_char_common",
                "required": true
              },
              {
                "field_id": "f_damage_size",
                "required": true
              },
              {
                "field_id": "f_room_size",
                "required": true
              },
              {
                "field_id": "f_year_last_caprepair",
                "required": true
              },
              {
                "field_id": "f_door_openings_count",
                "required": true
              },
              {
                "field_id": "f_window_openings_count",
                "required": true
              },
              {
                "field_id": "f_photos",
                "required": true
              }
            ]
          },
          {
            "id": "t_room_wall__",
            "when": {
              "category": "Помещение",
              "element": "Стена",
              "subelement": "Стеновые панели"
            },
            "fields": [
              {
                "field_id": "f_damage_subelement",
                "dictionary_id": "d_room_wall_subelement",
                "required": true
              },
              {
                "field_id": "f_material",
                "dictionary_id": "d_wall_panels_material",
                "required": true
              },
              {
                "field_id": "f_damage_char",
                "dictionary_id": "d_damage_char_common",
                "required": true
              },
              {
                "field_id": "f_damage_size",
                "required": true
              },
              {
                "field_id": "f_room_size",
                "required": true
              },
              {
                "field_id": "f_year_last_caprepair",
                "required": true
              },
              {
                "field_id": "f_door_openings_count",
                "required": true
              },
              {
                "field_id": "f_window_openings_count",
                "required": true
              },
              {
                "field_id": "f_photos",
                "required": true
              }
            ]
          },
          {
            "id": "t_room_wall__",
            "when": {
              "category": "Помещение",
              "element": "Стена",
              "subelement": "Ламинат"
            },
            "fields": [
              {
                "field_id": "f_damage_subelement",
                "dictionary_id": "d_room_wall_subelement",
                "required": true
              },
              {
                "field_id": "f_view",
                "dictionary_id": "d_wall_laminate_view",
                "required": true
              },
              {
                "field_id": "f_laminate_class",
                "dictionary_id": "d_laminate_class",
                "required": true
              },
              {
                "field_id": "f_damage_char",
                "dictionary_id": "d_damage_char_common",
                "required": true
              },
              {
                "field_id": "f_damage_size",
                "required": true
              },
              {
                "field_id": "f_room_size",
                "required": true
              },
              {
                "field_id": "f_year_last_caprepair",
                "required": true
              },
              {
                "field_id": "f_door_openings_count",
                "required": true
              },
              {
                "field_id": "f_window_openings_count",
                "required": true
              },
              {
                "field_id": "f_photos",
                "required": true
              }
            ]
          },
          {
            "id": "t_room_wall__",
            "when": {
              "category": "Помещение",
              "element": "Стена",
              "subelement": "Декоративная штукатурка"
            },
            "fields": [
              {
                "field_id": "f_damage_subelement",
                "dictionary_id": "d_room_wall_subelement",
                "required": true
              },
              {
                "field_id": "f_view",
                "dictionary_id": "d_wall_decorplaster_view",
                "required": true
              },
              {
                "field_id": "f_damage_char",
                "dictionary_id": "d_damage_char_common",
                "required": true
              },
              {
                "field_id": "f_damage_size",
                "required": true
              },
              {
                "field_id": "f_room_size",
                "required": true
              },
              {
                "field_id": "f_year_last_caprepair",
                "required": true
              },
              {
                "field_id": "f_door_openings_count",
                "required": true
              },
              {
                "field_id": "f_window_openings_count",
                "required": true
              },
              {
                "field_id": "f_photos",
                "required": true
              }
            ]
          },
          {
            "id": "t_room_wall__",
            "when": {
              "category": "Помещение",
              "element": "Стена",
              "subelement": "Декоративный камень"
            },
            "fields": [
              {
                "field_id": "f_damage_subelement",
                "dictionary_id": "d_room_wall_subelement",
                "required": true
              },
              {
                "field_id": "f_damage_char",
                "dictionary_id": "d_damage_char_common",
                "required": true
              },
              {
                "field_id": "f_damage_size",
                "required": true
              },
              {
                "field_id": "f_room_size",
                "required": true
              },
              {
                "field_id": "f_year_last_caprepair",
                "required": true
              },
              {
                "field_id": "f_door_openings_count",
                "required": true
              },
              {
                "field_id": "f_window_openings_count",
                "required": true
              },
              {
                "field_id": "f_photos",
                "required": true
              }
            ]
          },
          {
            "id": "t_room_wall__",
            "when": {
              "category": "Помещение",
              "element": "Стена",
              "subelement": "Лакокрасочное покрытие"
            },
            "fields": [
              {
                "field_id": "f_damage_subelement",
                "dictionary_id": "d_room_wall_subelement",
                "required": true
              },
              {
                "field_id": "f_view",
                "dictionary_id": "d_wall_paint_view",
                "required": true
              },
              {
                "field_id": "f_damage_char",
                "dictionary_id": "d_damage_char_common",
                "required": true
              },
              {
                "field_id": "f_damage_size",
                "required": true
              },
              {
                "field_id": "f_room_size",
                "required": true
              },
              {
                "field_id": "f_year_last_caprepair",
                "required": true
              },
              {
                "field_id": "f_door_openings_count",
                "required": true
              },
              {
                "field_id": "f_window_openings_count",
                "required": true
              },
              {
                "field_id": "f_photos",
                "required": true
              }
            ]
          },
          {
            "id": "t_room_wall__",
            "when": {
              "category": "Помещение",
              "element": "Стена",
              "subelement": "Обои"
            },
            "fields": [
              {
                "field_id": "f_damage_subelement",
                "dictionary_id": "d_room_wall_subelement",
                "required": true
              },
              {
                "field_id": "f_type",
                "dictionary_id": "d_wall_wallpaper_type",
                "required": true
              },
              {
                "field_id": "f_damage_char",
                "dictionary_id": "d_damage_char_common",
                "required": true
              },
              {
                "field_id": "f_damage_size",
                "required": true
              },
              {
                "field_id": "f_room_size",
                "required": true
              },
              {
                "field_id": "f_year_last_caprepair",
                "required": true
              },
              {
                "field_id": "f_door_openings_count",
                "required": true
              },
              {
                "field_id": "f_window_openings_count",
                "required": true
              },
              {
                "field_id": "f_photos",
                "required": true
              }
            ]
          },
          {
            "id": "t_room_wall__",
            "when": {
              "category": "Помещение",
              "element": "Стена",
              "subelement": "Плитка"
            },
            "fields": [
              {
                "field_id": "f_damage_subelement",
                "dictionary_id": "d_room_wall_subelement",
                "required": true
              },
              {
                "field_id": "f_view",
                "dictionary_id": "d_tile_view",
                "required": true
              },
              {
                "field_id": "f_damage_char",
                "dictionary_id": "d_damage_char_common",
                "required": true
              },
              {
                "field_id": "f_damage_size",
                "required": true
              },
              {
                "field_id": "f_room_size",
                "required": true
              },
              {
                "field_id": "f_year_last_caprepair",
                "required": true
              },
              {
                "field_id": "f_door_openings_count",
                "required": true
              },
              {
                "field_id": "f_window_openings_count",
                "required": true
              },
              {
                "field_id": "f_photos",
                "required": true
              }
            ]
          },
          {
            "id": "t_room_wall__",
            "when": {
              "category": "Помещение",
              "element": "Стена",
              "subelement": "Побелка"
            },
            "fields": [
              {
                "field_id": "f_damage_subelement",
                "dictionary_id": "d_room_wall_subelement",
                "required": true
              },
              {
                "field_id": "f_type",
                "dictionary_id": "d_wall_whitewash_type",
                "required": true
              },
              {
                "field_id": "f_damage_char",
                "dictionary_id": "d_damage_char_common",
                "required": true
              },
              {
                "field_id": "f_damage_size",
                "required": true
              },
              {
                "field_id": "f_room_size",
                "required": true
              },
              {
                "field_id": "f_year_last_caprepair",
                "required": true
              },
              {
                "field_id": "f_door_openings_count",
                "required": true
              },
              {
                "field_id": "f_window_openings_count",
                "required": true
              },
              {
                "field_id": "f_photos",
                "required": true
              }
            ]
          },
          {
            "id": "t_room_floor__",
            "when": {
              "category": "Помещение",
              "element": "Пол",
              "subelement": "Ковролин"
            },
            "fields": [
              {
                "field_id": "f_damage_subelement",
                "dictionary_id": "d_room_floor_subelement",
                "required": true
              },
              {
                "field_id": "f_type",
                "dictionary_id": "d_floor_carpet_type",
                "required": true
              },
              {
                "field_id": "f_damage_char",
                "dictionary_id": "d_damage_char_common",
                "required": true
              },
              {
                "field_id": "f_damage_size",
                "required": true
              },
              {
                "field_id": "f_room_size",
                "required": true
              },
              {
                "field_id": "f_year_last_caprepair",
                "required": true
              },
              {
                "field_id": "f_photos",
                "required": true
              }
            ]
          },
          {
            "id": "t_room_floor__",
            "when": {
              "category": "Помещение",
              "element": "Пол",
              "subelement": "Линолеум"
            },
            "fields": [
              {
                "field_id": "f_damage_subelement",
                "dictionary_id": "d_room_floor_subelement",
                "required": true
              },
              {
                "field_id": "f_type",
                "dictionary_id": "d_floor_lino_type",
                "required": true
              },
              {
                "field_id": "f_damage_char",
                "dictionary_id": "d_damage_char_common",
                "required": true
              },
              {
                "field_id": "f_damage_size",
                "required": true
              },
              {
                "field_id": "f_room_size",
                "required": true
              },
              {
                "field_id": "f_year_last_caprepair",
                "required": true
              },
              {
                "field_id": "f_photos",
                "required": true
              }
            ]
          },
          {
            "id": "t_room_floor__",
            "when": {
              "category": "Помещение",
              "element": "Пол",
              "subelement": "Плинтус напольный"
            },
            "fields": [
              {
                "field_id": "f_damage_subelement",
                "dictionary_id": "d_room_floor_subelement",
                "required": true
              },
              {
                "field_id": "f_material",
                "dictionary_id": "d_floor_plinth_material",
                "required": true
              },
              {
                "field_id": "f_damage_char",
                "dictionary_id": "d_damage_char_common",
                "required": true
              },
              {
                "field_id": "f_damage_size",
                "required": true
              },
              {
                "field_id": "f_room_size",
                "required": true
              },
              {
                "field_id": "f_year_last_caprepair",
                "required": true
              },
              {
                "field_id": "f_photos",
                "required": true
              }
            ]
          },
          {
            "id": "t_room_floor__",
            "when": {
              "category": "Помещение",
              "element": "Пол",
              "subelement": "Плитка"
            },
            "fields": [
              {
                "field_id": "f_damage_subelement",
                "dictionary_id": "d_room_floor_subelement",
                "required": true
              },
              {
                "field_id": "f_view",
                "dictionary_id": "d_tile_view",
                "required": true
              },
              {
                "field_id": "f_damage_char",
                "dictionary_id": "d_damage_char_common",
                "required": true
              },
              {
                "field_id": "f_damage_size",
                "required": true
              },
              {
                "field_id": "f_room_size",
                "required": true
              },
              {
                "field_id": "f_year_last_caprepair",
                "required": true
              },
              {
                "field_id": "f_photos",
                "required": true
              }
            ]
          },
          {
            "id": "t_room_floor__",
            "when": {
              "category": "Помещение",
              "element": "Пол",
              "subelement": "Паркет"
            },
            "fields": [
              {
                "field_id": "f_damage_subelement",
                "dictionary_id": "d_room_floor_subelement",
                "required": true
              },
              {
                "field_id": "f_view",
                "dictionary_id": "d_floor_parquet_view",
                "required": true
              },
              {
                "field_id": "f_material",
                "dictionary_id": "d_wood_species",
                "required": true
              },
              {
                "field_id": "f_damage_char",
                "dictionary_id": "d_damage_char_common",
                "required": true
              },
              {
                "field_id": "f_damage_size",
                "required": true
              },
              {
                "field_id": "f_room_size",
                "required": true
              },
              {
                "field_id": "f_year_last_caprepair",
                "required": true
              },
              {
                "field_id": "f_photos",
                "required": true
              }
            ]
          },
          {
            "id": "t_room_floor__",
            "when": {
              "category": "Помещение",
              "element": "Пол",
              "subelement": "Ламинат"
            },
            "fields": [
              {
                "field_id": "f_damage_subelement",
                "dictionary_id": "d_room_floor_subelement",
                "required": true
              },
              {
                "field_id": "f_details",
                "dictionary_id": "d_floor_laminate_details",
                "required": true
              },
              {
                "field_id": "f_laminate_class",
                "dictionary_id": "d_laminate_class",
                "required": true
              },
              {
                "field_id": "f_damage_char",
                "dictionary_id": "d_damage_char_common",
                "required": true
              },
              {
                "field_id": "f_damage_size",
                "required": true
              },
              {
                "field_id": "f_room_size",
                "required": true
              },
              {
                "field_id": "f_year_last_caprepair",
                "required": true
              },
              {
                "field_id": "f_photos",
                "required": true
              }
            ]
          },
          {
            "id": "t_room_window",
            "when": {
              "category": "Помещение",
              "element": "Окно"
            },
            "fields": [
              {
                "field_id": "f_window_material",
                "dictionary_id": "d_room_window_material",
                "required": true
              },
              {
                "field_id": "f_details",
                "required": false
              },
              {
                "field_id": "f_window_type",
                "dictionary_id": "d_window_type",
                "required": true
              },
              {
                "field_id": "f_window_size",
                "required": true
              },
              {
                "field_id": "f_glass_type",
                "dictionary_id": "d_glass_type_window",
                "required": true
              },
              {
                "field_id": "f_cameras",
                "dictionary_id": "d_cameras",
                "required": true
              },
              {
                "field_id": "f_film_type",
                "dictionary_id": "d_film_type",
                "required": true
              },
              {
                "field_id": "f_glasspack_size",
                "required": true
              },
              {
                "field_id": "f_glass_thickness_mm",
                "required": true
              },
              {
                "field_id": "f_glass_formula",
                "required": false
              },
              {
                "field_id": "f_damage_char",
                "dictionary_id": "d_damage_char_common",
                "required": true
              },
              {
                "field_id": "f_damage_size",
                "required": true
              },
              {
                "field_id": "f_photos",
                "required": true
              }
            ]
          },
          {
            "id": "t_room_door",
            "when": {
              "category": "Помещение",
              "element": "Дверь"
            },
            "fields": [
              {
                "field_id": "f_door_material",
                "dictionary_id": "d_room_door_material",
                "required": true
              },
              {
                "field_id": "f_details",
                "required": false
              },
              {
                "field_id": "f_door_type",
                "dictionary_id": "d_door_type",
                "required": true
              },
              {
                "field_id": "f_door_size",
                "required": true
              },
              {
                "field_id": "f_glass_type",
                "dictionary_id": "d_glass_type_door_room",
                "required": false
              },
              {
                "field_id": "f_cameras",
                "dictionary_id": "d_cameras",
                "required": false
              },
              {
                "field_id": "f_film_type",
                "dictionary_id": "d_film_type",
                "required": false
              },
              {
                "field_id": "f_glasspack_size",
                "required": false
              },
              {
                "field_id": "f_glass_thickness_mm",
                "required": false
              },
              {
                "field_id": "f_glass_formula",
                "required": false
              },
              {
                "field_id": "f_damage_char",
                "dictionary_id": "d_damage_char_common",
                "required": true
              },
              {
                "field_id": "f_damage_size",
                "required": true
              },
              {
                "field_id": "f_photos",
                "required": true
              }
            ]
          },
          {
            "id": "t_room_other_element",
            "when": {
              "category": "Помещение",
              "element_in": [
                "Иное",
                "Не знаю / Затрудняюсь ответить"
              ]
            },
            "fields": [
              {
                "field_id": "f_damage_char",
                "dictionary_id": "d_damage_char_common",
                "required": true
              },
              {
                "field_id": "f_damage_size",
                "required": true
              },
              {
                "field_id": "f_room_size",
                "required": true
              },
              {
                "field_id": "f_year_last_caprepair",
                "required": true
              },
              {
                "field_id": "f_photos",
                "required": true
              }
            ]
          },
          {
            "id": "t_building_facade_vent",
            "when": {
              "category": "Здание",
              "element": "Фасад",
              "subelement": "Вентилируемый фасад"
            },
            "fields": [
              {
                "field_id": "f_damage_subelement",
                "dictionary_id": "d_building_facade_subelement",
                "required": true
              },
              {
                "field_id": "f_facade_cladding",
                "dictionary_id": "d_facade_vent_cladding",
                "required": true
              },
              {
                "field_id": "f_facade_frame",
                "dictionary_id": "d_facade_vent_frame",
                "required": true
              },
              {
                "field_id": "f_facade_insulation",
                "dictionary_id": "d_facade_vent_insulation",
                "required": true
              },
              {
                "field_id": "f_damage_char",
                "dictionary_id": "d_damage_char_common",
                "required": true
              },
              {
                "field_id": "f_damage_size",
                "required": true
              },
              {
                "field_id": "f_year_built",
                "required": true
              },
              {
                "field_id": "f_year_last_caprepair",
                "required": true
              },
              {
                "field_id": "f_photos",
                "required": true
              }
            ]
          },
          {
            "id": "t_building_facade_sheathing",
            "when": {
              "category": "Здание",
              "element": "Фасад",
              "subelement": "Обшивка"
            },
            "fields": [
              {
                "field_id": "f_damage_subelement",
                "dictionary_id": "d_building_facade_subelement",
                "required": true
              },
              {
                "field_id": "f_view",
                "dictionary_id": "d_facade_sheathing_view",
                "required": true
              },
              {
                "field_id": "f_material",
                "required": false
              },
              {
                "field_id": "f_type",
                "required": false
              },
              {
                "field_id": "f_damage_char",
                "dictionary_id": "d_damage_char_common",
                "required": true
              },
              {
                "field_id": "f_damage_size",
                "required": true
              },
              {
                "field_id": "f_year_built",
                "required": true
              },
              {
                "field_id": "f_year_last_caprepair",
                "required": true
              },
              {
                "field_id": "f_photos",
                "required": true
              }
            ]
          },
          {
            "id": "t_building_facade_cladding",
            "when": {
              "category": "Здание",
              "element": "Фасад",
              "subelement": "Облицовка"
            },
            "fields": [
              {
                "field_id": "f_damage_subelement",
                "dictionary_id": "d_building_facade_subelement",
                "required": true
              },
              {
                "field_id": "f_material",
                "dictionary_id": "d_facade_cladding_material",
                "required": true
              },
              {
                "field_id": "f_type",
                "required": false
              },
              {
                "field_id": "f_damage_char",
                "dictionary_id": "d_damage_char_common",
                "required": true
              },
              {
                "field_id": "f_damage_size",
                "required": true
              },
              {
                "field_id": "f_year_built",
                "required": true
              },
              {
                "field_id": "f_year_last_caprepair",
                "required": true
              },
              {
                "field_id": "f_photos",
                "required": true
              }
            ]
          },
          {
            "id": "t_building_roof_roofing",
            "when": {
              "category": "Здание",
              "element": "Крыша",
              "subelement": "Кровля"
            },
            "fields": [
              {
                "field_id": "f_damage_subelement",
                "dictionary_id": "d_building_roof_subelement",
                "required": true
              },
              {
                "field_id": "f_roof_view",
                "dictionary_id": "d_roof_view",
                "required": true
              },
              {
                "field_id": "f_roof_covering",
                "dictionary_id": "d_roof_covering",
                "required": true
              },
              {
                "field_id": "f_roof_hydro",
                "dictionary_id": "d_roof_hydro",
                "required": true
              },
              {
                "field_id": "f_roof_insulation",
                "dictionary_id": "d_roof_insulation",
                "required": true
              },
              {
                "field_id": "f_roof_rafters_material",
                "dictionary_id": "d_roof_rafters_material",
                "required": true
              },
              {
                "field_id": "f_damage_char",
                "dictionary_id": "d_damage_char_common",
                "required": true
              },
              {
                "field_id": "f_damage_size",
                "required": true
              },
              {
                "field_id": "f_year_built",
                "required": true
              },
              {
                "field_id": "f_year_last_caprepair",
                "required": true
              },
              {
                "field_id": "f_photos",
                "required": true
              }
            ]
          },
          {
            "id": "t_building_roof_gutter",
            "when": {
              "category": "Здание",
              "element": "Крыша",
              "subelement": "Водосточная система"
            },
            "fields": [
              {
                "field_id": "f_damage_subelement",
                "dictionary_id": "d_building_roof_subelement",
                "required": true
              },
              {
                "field_id": "f_gutter_material",
                "dictionary_id": "d_gutter_material",
                "required": true
              },
              {
                "field_id": "f_damage_char",
                "dictionary_id": "d_damage_char_common",
                "required": true
              },
              {
                "field_id": "f_damage_size",
                "required": true
              },
              {
                "field_id": "f_year_last_caprepair",
                "required": true
              },
              {
                "field_id": "f_photos",
                "required": true
              }
            ]
          },
          {
            "id": "t_building_roof_snowguards",
            "when": {
              "category": "Здание",
              "element": "Крыша",
              "subelement": "Снегозадержатели"
            },
            "fields": [
              {
                "field_id": "f_damage_subelement",
                "dictionary_id": "d_building_roof_subelement",
                "required": true
              },
              {
                "field_id": "f_snowguards_type",
                "dictionary_id": "d_snowguards_type",
                "required": true
              },
              {
                "field_id": "f_damage_char",
                "dictionary_id": "d_damage_char_common",
                "required": true
              },
              {
                "field_id": "f_damage_size",
                "required": true
              },
              {
                "field_id": "f_year_last_caprepair",
                "required": true
              },
              {
                "field_id": "f_photos",
                "required": true
              }
            ]
          },
          {
            "id": "t_building_arch_cornices",
            "when": {
              "category": "Здание",
              "element": "Архитектурные элементы",
              "subelement": "Карнизы"
            },
            "fields": [
              {
                "field_id": "f_damage_subelement",
                "dictionary_id": "d_building_arch_subelement",
                "required": true
              },
              {
                "field_id": "f_material",
                "dictionary_id": "d_arch_cornice_material",
                "required": true
              },
              {
                "field_id": "f_damage_char",
                "dictionary_id": "d_damage_char_common",
                "required": true
              },
              {
                "field_id": "f_damage_size",
                "required": true
              },
              {
                "field_id": "f_year_built",
                "required": true
              },
              {
                "field_id": "f_year_last_caprepair",
                "required": true
              },
              {
                "field_id": "f_photos",
                "required": true
              }
            ]
          },
          {
            "id": "t_building_arch_platbands",
            "when": {
              "category": "Здание",
              "element": "Архитектурные элементы",
              "subelement": "Наличники"
            },
            "fields": [
              {
                "field_id": "f_damage_subelement",
                "dictionary_id": "d_building_arch_subelement",
                "required": true
              },
              {
                "field_id": "f_material",
                "dictionary_id": "d_arch_platband_material",
                "required": true
              },
              {
                "field_id": "f_damage_char",
                "dictionary_id": "d_damage_char_common",
                "required": true
              },
              {
                "field_id": "f_damage_size",
                "required": true
              },
              {
                "field_id": "f_year_built",
                "required": true
              },
              {
                "field_id": "f_year_last_caprepair",
                "required": true
              },
              {
                "field_id": "f_photos",
                "required": true
              }
            ]
          },
          {
            "id": "t_building_arch_grilles",
            "when": {
              "category": "Здание",
              "element": "Архитектурные элементы",
              "subelement": "Решетки"
            },
            "fields": [
              {
                "field_id": "f_damage_subelement",
                "dictionary_id": "d_building_arch_subelement",
                "required": true
              },
              {
                "field_id": "f_view",
                "dictionary_id": "d_arch_grille_view",
                "required": true
              },
              {
                "field_id": "f_damage_char",
                "dictionary_id": "d_damage_char_common",
                "required": true
              },
              {
                "field_id": "f_damage_size",
                "required": true
              },
              {
                "field_id": "f_year_built",
                "required": true
              },
              {
                "field_id": "f_year_last_caprepair",
                "required": true
              },
              {
                "field_id": "f_photos",
                "required": true
              }
            ]
          },
          {
            "id": "t_building_arch_shutters",
            "when": {
              "category": "Здание",
              "element": "Архитектурные элементы",
              "subelement": "Ставни"
            },
            "fields": [
              {
                "field_id": "f_damage_subelement",
                "dictionary_id": "d_building_arch_subelement",
                "required": true
              },
              {
                "field_id": "f_view",
                "dictionary_id": "d_arch_shutter_view",
                "required": true
              },
              {
                "field_id": "f_damage_char",
                "dictionary_id": "d_damage_char_common",
                "required": true
              },
              {
                "field_id": "f_damage_size",
                "required": true
              },
              {
                "field_id": "f_year_built",
                "required": true
              },
              {
                "field_id": "f_year_last_caprepair",
                "required": true
              },
              {
                "field_id": "f_photos",
                "required": true
              }
            ]
          },
          {
            "id": "t_building_const_walls",
            "when": {
              "category": "Здание",
              "element": "Конструктивные элементы",
              "subelement": "Стены"
            },
            "fields": [
              {
                "field_id": "f_damage_subelement",
                "dictionary_id": "d_building_construct_subelement",
                "required": true
              },
              {
                "field_id": "f_material",
                "dictionary_id": "d_construct_walls_material",
                "required": true
              },
              {
                "field_id": "f_damage_char",
                "dictionary_id": "d_damage_char_common",
                "required": true
              },
              {
                "field_id": "f_damage_size",
                "required": true
              },
              {
                "field_id": "f_year_built",
                "required": true
              },
              {
                "field_id": "f_year_last_caprepair",
                "required": true
              },
              {
                "field_id": "f_photos",
                "required": true
              }
            ]
          },
          {
            "id": "t_building_const_floors",
            "when": {
              "category": "Здание",
              "element": "Конструктивные элементы",
              "subelement": "Перекрытия"
            },
            "fields": [
              {
                "field_id": "f_damage_subelement",
                "dictionary_id": "d_building_construct_subelement",
                "required": true
              },
              {
                "field_id": "f_material",
                "dictionary_id": "d_construct_floors_material",
                "required": true
              },
              {
                "field_id": "f_damage_char",
                "dictionary_id": "d_damage_char_common",
                "required": true
              },
              {
                "field_id": "f_damage_size",
                "required": true
              },
              {
                "field_id": "f_year_built",
                "required": true
              },
              {
                "field_id": "f_year_last_caprepair",
                "required": true
              },
              {
                "field_id": "f_photos",
                "required": true
              }
            ]
          },
          {
            "id": "t_building_const_steps",
            "when": {
              "category": "Здание",
              "element": "Конструктивные элементы",
              "subelement": "Ступени"
            },
            "fields": [
              {
                "field_id": "f_damage_subelement",
                "dictionary_id": "d_building_construct_subelement",
                "required": true
              },
              {
                "field_id": "f_material",
                "dictionary_id": "d_construct_steps_material",
                "required": true
              },
              {
                "field_id": "f_damage_char",
                "dictionary_id": "d_damage_char_common",
                "required": true
              },
              {
                "field_id": "f_damage_size",
                "required": true
              },
              {
                "field_id": "f_year_built",
                "required": true
              },
              {
                "field_id": "f_year_last_caprepair",
                "required": true
              },
              {
                "field_id": "f_photos",
                "required": true
              }
            ]
          },
          {
            "id": "t_building_const_foundation",
            "when": {
              "category": "Здание",
              "element": "Конструктивные элементы",
              "subelement": "Фундамент"
            },
            "fields": [
              {
                "field_id": "f_damage_subelement",
                "dictionary_id": "d_building_construct_subelement",
                "required": true
              },
              {
                "field_id": "f_type",
                "dictionary_id": "d_construct_foundation_type",
                "required": true
              },
              {
                "field_id": "f_damage_char",
                "dictionary_id": "d_damage_char_common",
                "required": true
              },
              {
                "field_id": "f_damage_size",
                "required": true
              },
              {
                "field_id": "f_year_built",
                "required": true
              },
              {
                "field_id": "f_year_last_caprepair",
                "required": true
              },
              {
                "field_id": "f_photos",
                "required": true
              }
            ]
          },
          {
            "id": "t_building_const_socle",
            "when": {
              "category": "Здание",
              "element": "Конструктивные элементы",
              "subelement": "Цоколь"
            },
            "fields": [
              {
                "field_id": "f_damage_subelement",
                "dictionary_id": "d_building_construct_subelement",
                "required": true
              },
              {
                "field_id": "f_socle_finish",
                "dictionary_id": "d_construct_socle_finish",
                "required": true
              },
              {
                "field_id": "f_damage_char",
                "dictionary_id": "d_damage_char_common",
                "required": true
              },
              {
                "field_id": "f_damage_size",
                "required": true
              },
              {
                "field_id": "f_year_built",
                "required": true
              },
              {
                "field_id": "f_year_last_caprepair",
                "required": true
              },
              {
                "field_id": "f_photos",
                "required": true
              }
            ]
          },
          {
            "id": "t_glazing_window",
            "when": {
              "category": "Остекление",
              "element": "Окно"
            },
            "fields": [
              {
                "field_id": "f_window_material",
                "dictionary_id": "d_glazing_window_material",
                "required": true
              },
              {
                "field_id": "f_details",
                "required": false
              },
              {
                "field_id": "f_window_type",
                "dictionary_id": "d_window_type",
                "required": true
              },
              {
                "field_id": "f_window_size",
                "required": true
              },
              {
                "field_id": "f_glass_type",
                "dictionary_id": "d_glass_type_window",
                "required": true
              },
              {
                "field_id": "f_cameras",
                "dictionary_id": "d_cameras",
                "required": true
              },
              {
                "field_id": "f_film_type",
                "dictionary_id": "d_film_type",
                "required": true
              },
              {
                "field_id": "f_glasspack_size",
                "required": true
              },
              {
                "field_id": "f_glass_thickness_mm",
                "required": true
              },
              {
                "field_id": "f_glass_formula",
                "required": false
              },
              {
                "field_id": "f_damage_char",
                "dictionary_id": "d_damage_char_glazing",
                "required": true
              },
              {
                "field_id": "f_damage_size",
                "required": true
              },
              {
                "field_id": "f_photos",
                "required": true
              }
            ]
          },
          {
            "id": "t_glazing_door",
            "when": {
              "category": "Остекление",
              "element": "Дверь"
            },
            "fields": [
              {
                "field_id": "f_door_material",
                "dictionary_id": "d_glazing_door_material",
                "required": true
              },
              {
                "field_id": "f_details",
                "required": false
              },
              {
                "field_id": "f_door_type",
                "dictionary_id": "d_door_type",
                "required": true
              },
              {
                "field_id": "f_door_size",
                "required": true
              },
              {
                "field_id": "f_glass_type",
                "dictionary_id": "d_glass_type_door_glazing",
                "required": false
              },
              {
                "field_id": "f_cameras",
                "dictionary_id": "d_cameras",
                "required": false
              },
              {
                "field_id": "f_film_type",
                "dictionary_id": "d_film_type",
                "required": false
              },
              {
                "field_id": "f_glasspack_size",
                "required": false
              },
              {
                "field_id": "f_glass_thickness_mm",
                "required": false
              },
              {
                "field_id": "f_glass_formula",
                "required": false
              },
              {
                "field_id": "f_damage_char",
                "dictionary_id": "d_damage_char_glazing",
                "required": true
              },
              {
                "field_id": "f_damage_size",
                "required": true
              },
              {
                "field_id": "f_photos",
                "required": true
              }
            ]
          },
          {
            "id": "t_glazing_other_element",
            "when": {
              "category": "Остекление",
              "element_in": [
                "Иное",
                "Не знаю / Затрудняюсь ответить"
              ]
            },
            "fields": [
              {
                "field_id": "f_damage_char",
                "dictionary_id": "d_damage_char_glazing",
                "required": true
              },
              {
                "field_id": "f_damage_size",
                "required": true
              },
              {
                "field_id": "f_photos",
                "required": true
              }
            ]
          },
          {
            "id": "t_furniture",
            "when": {
              "category": "Мебель"
            },
            "fields": [
              {
                "field_id": "f_furniture_name",
                "required": true
              },
              {
                "field_id": "f_furniture_brand",
                "required": false
              },
              {
                "field_id": "f_furniture_year",
                "required": false
              },
              {
                "field_id": "f_furniture_info",
                "required": false
              },
              {
                "field_id": "f_damage_char",
                "dictionary_id": "d_damage_char_common",
                "required": true
              },
              {
                "field_id": "f_damage_size",
                "required": true
              },
              {
                "field_id": "f_photos",
                "required": true
              }
            ]
          },
          {
            "id": "t_room_ceiling_other_subelement",
            "when": {
              "category": "Помещение",
              "element": "Потолок",
              "subelement_in": [
                "Иное",
                "Не знаю / Затрудняюсь ответить"
              ]
            },
            "fields": [
              {
                "field_id": "f_damage_subelement",
                "dictionary_id": "d_room_ceiling_subelement",
                "required": true
              },
              {
                "field_id": "f_damage_char",
                "dictionary_id": "d_damage_char_common",
                "required": true
              },
              {
                "field_id": "f_damage_size",
                "required": true
              },
              {
                "field_id": "f_room_size",
                "required": true
              },
              {
                "field_id": "f_year_last_caprepair",
                "required": true
              },
              {
                "field_id": "f_photos",
                "required": true
              }
            ]
          },
          {
            "id": "t_room_wall_other_subelement",
            "when": {
              "category": "Помещение",
              "element": "Стена",
              "subelement_in": [
                "Иное",
                "Не знаю / Затрудняюсь ответить"
              ]
            },
            "fields": [
              {
                "field_id": "f_damage_subelement",
                "dictionary_id": "d_room_wall_subelement",
                "required": true
              },
              {
                "field_id": "f_damage_char",
                "dictionary_id": "d_damage_char_common",
                "required": true
              },
              {
                "field_id": "f_damage_size",
                "required": true
              },
              {
                "field_id": "f_room_size",
                "required": true
              },
              {
                "field_id": "f_year_last_caprepair",
                "required": true
              },
              {
                "field_id": "f_door_openings_count",
                "required": true
              },
              {
                "field_id": "f_window_openings_count",
                "required": true
              },
              {
                "field_id": "f_photos",
                "required": true
              }
            ]
          },
          {
            "id": "t_room_floor_other_subelement",
            "when": {
              "category": "Помещение",
              "element": "Пол",
              "subelement_in": [
                "Иное",
                "Не знаю / Затрудняюсь ответить"
              ]
            },
            "fields": [
              {
                "field_id": "f_damage_subelement",
                "dictionary_id": "d_room_floor_subelement",
                "required": true
              },
              {
                "field_id": "f_damage_char",
                "dictionary_id": "d_damage_char_common",
                "required": true
              },
              {
                "field_id": "f_damage_size",
                "required": true
              },
              {
                "field_id": "f_room_size",
                "required": true
              },
              {
                "field_id": "f_year_last_caprepair",
                "required": true
              },
              {
                "field_id": "f_photos",
                "required": true
              }
            ]
          },
          {
            "id": "t_building_other_element",
            "when": {
              "category": "Здание",
              "element_in": [
                "Иное",
                "Не знаю / Затрудняюсь ответить"
              ]
            },
            "fields": [
              {
                "field_id": "f_damage_char",
                "dictionary_id": "d_damage_char_common",
                "required": true
              },
              {
                "field_id": "f_damage_size",
                "required": true
              },
              {
                "field_id": "f_year_built",
                "required": true
              },
              {
                "field_id": "f_year_last_caprepair",
                "required": true
              },
              {
                "field_id": "f_photos",
                "required": true
              }
            ]
          },
          {
            "id": "t_building_facade_other_subelement",
            "when": {
              "category": "Здание",
              "element": "Фасад",
              "subelement_in": [
                "Иное",
                "Не знаю / Затрудняюсь ответить"
              ]
            },
            "fields": [
              {
                "field_id": "f_damage_subelement",
                "dictionary_id": "d_building_facade_subelement",
                "required": true
              },
              {
                "field_id": "f_damage_char",
                "dictionary_id": "d_damage_char_common",
                "required": true
              },
              {
                "field_id": "f_damage_size",
                "required": true
              },
              {
                "field_id": "f_year_built",
                "required": true
              },
              {
                "field_id": "f_year_last_caprepair",
                "required": true
              },
              {
                "field_id": "f_photos",
                "required": true
              }
            ]
          },
          {
            "id": "t_building_roof_other_subelement",
            "when": {
              "category": "Здание",
              "element": "Крыша",
              "subelement_in": [
                "Иное",
                "Не знаю / Затрудняюсь ответить"
              ]
            },
            "fields": [
              {
                "field_id": "f_damage_subelement",
                "dictionary_id": "d_building_roof_subelement",
                "required": true
              },
              {
                "field_id": "f_damage_char",
                "dictionary_id": "d_damage_char_common",
                "required": true
              },
              {
                "field_id": "f_damage_size",
                "required": true
              },
              {
                "field_id": "f_year_last_caprepair",
                "required": true
              },
              {
                "field_id": "f_photos",
                "required": true
              }
            ]
          },
          {
            "id": "t_building_arch_other_subelement",
            "when": {
              "category": "Здание",
              "element": "Архитектурные элементы",
              "subelement_in": [
                "Иное",
                "Не знаю / Затрудняюсь ответить"
              ]
            },
            "fields": [
              {
                "field_id": "f_damage_subelement",
                "dictionary_id": "d_building_arch_subelement",
                "required": true
              },
              {
                "field_id": "f_damage_char",
                "dictionary_id": "d_damage_char_common",
                "required": true
              },
              {
                "field_id": "f_damage_size",
                "required": true
              },
              {
                "field_id": "f_year_built",
                "required": true
              },
              {
                "field_id": "f_year_last_caprepair",
                "required": true
              },
              {
                "field_id": "f_photos",
                "required": true
              }
            ]
          },
          {
            "id": "t_building_construct_other_subelement",
            "when": {
              "category": "Здание",
              "element": "Конструктивные элементы",
              "subelement_in": [
                "Иное",
                "Не знаю / Затрудняюсь ответить"
              ]
            },
            "fields": [
              {
                "field_id": "f_damage_subelement",
                "dictionary_id": "d_building_construct_subelement",
                "required": true
              },
              {
                "field_id": "f_damage_char",
                "dictionary_id": "d_damage_char_common",
                "required": true
              },
              {
                "field_id": "f_damage_size",
                "required": true
              },
              {
                "field_id": "f_year_built",
                "required": true
              },
              {
                "field_id": "f_year_last_caprepair",
                "required": true
              },
              {
                "field_id": "f_photos",
                "required": true
              }
            ]
          }
        ]
      }
    },
    "rules": [
      {
        "id": "r_damage_element_dictionary_by_category",
        "when": {
          "field": "f_damage_category"
        },
        "actions": [
          {
            "type": "set_dictionary",
            "field_id": "f_damage_element",
            "by_value": {
              "Помещение": "d_element_room",
              "Здание": "d_element_building",
              "Остекление": "d_element_glazing"
            },
            "else": null
          },
          {
            "type": "clear_fields",
            "field_ids": [
              "f_damage_element",
              "f_damage_subelement"
            ]
          }
        ],
        "note": "При смене категории обновляется справочник элементов; значения элемента/подэлемента очищаются."
      },
      {
        "id": "r_damage_subelement_dictionary_by_category_element",
        "when": {
          "fields": [
            "f_damage_category",
            "f_damage_element"
          ]
        },
        "actions": [
          {
            "type": "set_dictionary_and_visibility",
            "field_id": "f_damage_subelement",
            "cases": [
              {
                "if": {
                  "category": "Помещение",
                  "element": "Потолок"
                },
                "dictionary_id": "d_room_ceiling_subelement",
                "visible": true,
                "required": true
              },
              {
                "if": {
                  "category": "Помещение",
                  "element": "Стена"
                },
                "dictionary_id": "d_room_wall_subelement",
                "visible": true,
                "required": true
              },
              {
                "if": {
                  "category": "Помещение",
                  "element": "Пол"
                },
                "dictionary_id": "d_room_floor_subelement",
                "visible": true,
                "required": true
              },
              {
                "if": {
                  "category": "Здание",
                  "element": "Фасад"
                },
                "dictionary_id": "d_building_facade_subelement",
                "visible": true,
                "required": true
              },
              {
                "if": {
                  "category": "Здание",
                  "element": "Крыша"
                },
                "dictionary_id": "d_building_roof_subelement",
                "visible": true,
                "required": true
              },
              {
                "if": {
                  "category": "Здание",
                  "element": "Архитектурные элементы"
                },
                "dictionary_id": "d_building_arch_subelement",
                "visible": true,
                "required": true
              },
              {
                "if": {
                  "category": "Здание",
                  "element": "Конструктивные элементы"
                },
                "dictionary_id": "d_building_construct_subelement",
                "visible": true,
                "required": true
              }
            ],
            "default": {
              "visible": false,
              "required": false,
              "dictionary_id": null
            }
          },
          {
            "type": "clear_fields",
            "field_ids": [
              "f_damage_subelement"
            ]
          }
        ],
        "note": "Показывать/скрывать Подэлемент в зависимости от выбранного элемента."
      },
      {
        "id": "r_clear_damage_size_on_selectors_change",
        "when": {
          "fields": [
            "f_damage_category",
            "f_damage_element",
            "f_damage_subelement"
          ]
        },
        "actions": [
          {
            "type": "clear_fields",
            "field_ids": [
              "f_damage_size"
            ]
          }
        ],
        "note": "При изменении Категории/Элемента/Подэлемента сбрасывать размеры повреждения, чтобы значения не переносились между разными объектами."
      },
      {
        "id": "r_details_by_material_window",
        "when": {
          "field": "f_window_material"
        },
        "actions": [
          {
            "type": "set_dictionary_and_visibility",
            "field_id": "f_details",
            "cases": [
              {
                "if": {
                  "value": "Дерево"
                },
                "dictionary_id": "d_wood_species",
                "visible": true,
                "required": true
              },
              {
                "if": {
                  "value": "Металл"
                },
                "dictionary_id": "d_metal_details",
                "visible": true,
                "required": true
              }
            ],
            "default": {
              "visible": false,
              "required": false,
              "dictionary_id": null,
              "clear": true
            }
          }
        ]
      },
      {
        "id": "r_details_by_material_door",
        "when": {
          "field": "f_door_material"
        },
        "actions": [
          {
            "type": "set_dictionary_and_visibility",
            "field_id": "f_details",
            "cases": [
              {
                "if": {
                  "value": "Дерево"
                },
                "dictionary_id": "d_wood_species",
                "visible": true,
                "required": true
              },
              {
                "if": {
                  "value": "Металл"
                },
                "dictionary_id": "d_metal_details",
                "visible": true,
                "required": true
              }
            ],
            "default": {
              "visible": false,
              "required": false,
              "dictionary_id": null,
              "clear": true
            }
          }
        ]
      },
      {
        "id": "r_room_door_glass_block_only_if_material_glass",
        "when": {
          "fields": [
            "f_damage_category",
            "f_damage_element",
            "f_door_material"
          ]
        },
        "actions": [
          {
            "type": "set_visibility_and_required",
            "field_ids": [
              "f_glass_type",
              "f_cameras",
              "f_film_type",
              "f_glasspack_size",
              "f_glass_thickness_mm",
              "f_glass_formula"
            ],
            "if": {
              "category": "Помещение",
              "element": "Дверь",
              "material": "Стекло"
            },
            "visible": true,
            "required_fields": [
              "f_glass_type",
              "f_cameras",
              "f_film_type",
              "f_glasspack_size",
              "f_glass_thickness_mm"
            ],
            "dictionary_overrides": {
              "f_glass_type": "d_glass_type_door_room"
            },
            "else": {
              "visible": false,
              "clear": true
            }
          }
        ]
      },
      {
        "id": "r_glazing_door_glass_block_only_if_material_glass",
        "when": {
          "fields": [
            "f_damage_category",
            "f_damage_element",
            "f_door_material"
          ]
        },
        "actions": [
          {
            "type": "set_visibility_and_required",
            "field_ids": [
              "f_glass_type",
              "f_cameras",
              "f_film_type",
              "f_glasspack_size",
              "f_glass_thickness_mm",
              "f_glass_formula"
            ],
            "if": {
              "category": "Остекление",
              "element": "Дверь",
              "material": "Стекло"
            },
            "visible": true,
            "required_fields": [
              "f_glass_type",
              "f_cameras",
              "f_film_type",
              "f_glasspack_size",
              "f_glass_thickness_mm"
            ],
            "dictionary_overrides": {
              "f_glass_type": "d_glass_type_door_glazing"
            },
            "else": {
              "visible": false,
              "clear": true
            }
          }
        ]
      },
      {
        "id": "r_building_facade_sheathing_view_drives_material_or_type",
        "when": {
          "fields": [
            "f_damage_category",
            "f_damage_element",
            "f_damage_subelement",
            "f_view"
          ]
        },
        "actions": [
          {
            "type": "set_field_visibility_dictionary_required",
            "cases": [
              {
                "if": {
                  "category": "Здание",
                  "element": "Фасад",
                  "subelement": "Обшивка",
                  "view": "Вагонка"
                },
                "show": [
                  {
                    "field_id": "f_material",
                    "dictionary_id": "d_facade_sheathing_vagonka_material",
                    "required": true
                  }
                ],
                "hide": [
                  "f_type"
                ]
              },
              {
                "if": {
                  "category": "Здание",
                  "element": "Фасад",
                  "subelement": "Обшивка",
                  "view": "Тес"
                },
                "show": [
                  {
                    "field_id": "f_material",
                    "dictionary_id": "d_facade_sheathing_tes_material",
                    "required": true
                  }
                ],
                "hide": [
                  "f_type"
                ]
              },
              {
                "if": {
                  "category": "Здание",
                  "element": "Фасад",
                  "subelement": "Обшивка",
                  "view": "Термодревисина"
                },
                "show": [
                  {
                    "field_id": "f_material",
                    "dictionary_id": "d_facade_sheathing_thermo_material",
                    "required": true
                  }
                ],
                "hide": [
                  "f_type"
                ]
              },
              {
                "if": {
                  "category": "Здание",
                  "element": "Фасад",
                  "subelement": "Обшивка",
                  "view": "Сайдинг"
                },
                "show": [
                  {
                    "field_id": "f_type",
                    "dictionary_id": "d_facade_siding_type",
                    "required": true
                  }
                ],
                "hide": [
                  "f_material"
                ]
              },
              {
                "if": {
                  "category": "Здание",
                  "element": "Фасад",
                  "subelement": "Обшивка",
                  "view": "Имитация бруса"
                },
                "hide": [
                  "f_material",
                  "f_type"
                ]
              }
            ],
            "default": {
              "hide": [
                "f_material",
                "f_type"
              ]
            }
          }
        ],
        "note": "Для фасада/обшивки: материалы только для Вагонка/Тес/Термодревисина; тип только для Сайдинг."
      },
      {
        "id": "r_building_facade_cladding_material_drives_type_dictionary",
        "when": {
          "fields": [
            "f_damage_category",
            "f_damage_element",
            "f_damage_subelement",
            "f_material"
          ]
        },
        "actions": [
          {
            "type": "set_field_visibility_dictionary_required",
            "cases": [
              {
                "if": {
                  "category": "Здание",
                  "element": "Фасад",
                  "subelement": "Облицовка",
                  "material": "Фасадная плитка"
                },
                "show": [
                  {
                    "field_id": "f_type",
                    "dictionary_id": "d_facade_tile_type",
                    "required": true
                  }
                ]
              },
              {
                "if": {
                  "category": "Здание",
                  "element": "Фасад",
                  "subelement": "Облицовка",
                  "material": "Декоративная штукатурка"
                },
                "show": [
                  {
                    "field_id": "f_type",
                    "dictionary_id": "d_facade_plaster_type",
                    "required": true
                  }
                ]
              },
              {
                "if": {
                  "category": "Здание",
                  "element": "Фасад",
                  "subelement": "Облицовка",
                  "material": "Лакокрасочное покрытие"
                },
                "show": [
                  {
                    "field_id": "f_type",
                    "dictionary_id": "d_facade_paint_type",
                    "required": true
                  }
                ]
              },
              {
                "if": {
                  "category": "Здание",
                  "element": "Фасад",
                  "subelement": "Облицовка",
                  "material": "Побелка"
                },
                "show": [
                  {
                    "field_id": "f_type",
                    "dictionary_id": "d_facade_whitewash_type",
                    "required": true
                  }
                ]
              }
            ],
            "default": {
              "hide": [
                "f_type"
              ]
            }
          }
        ],
        "note": "Для фасада/облицовки: поле Тип появляется только для перечисленных материалов."
      },
      {
        "id": "r_hide_element_selector_for_furniture",
        "when": {
          "field": "f_damage_category"
        },
        "actions": [
          {
            "type": "set_visibility_and_required",
            "field_ids": ["f_damage_element"],
            "if": {
              "category": "Мебель"
            },
            "visible": false,
            "else": {
              "visible": true
            },
            "if_required": false,
            "else_required": true
          },
          {
            "type": "clear_fields",
            "field_ids": [
              "f_damage_element",
              "f_damage_subelement"
            ],
            "if": {
              "category": "Мебель"
            }
          }
        ],
        "note": "Для категории Мебель элемент/подэлемент не используются."
      }
    ],
    "export": {
      "pdf": {
        "omit_values": [
          "Нет повреждений"
        ],
        "header": [
          {
            "label": "Дата акта",
            "source": "f_inspection_date"
          },
          {
            "label": "№ акта",
            "source_static": "№1"
          },
          {
            "label": "Договор",
            "fields": [
              {
                "field_id": "f_policy_date",
                "label": "дата"
              },
              {
                "field_id": "f_policy_number",
                "label": "номер"
              }
            ]
          },
          {
            "label": "Страхователь",
            "field_id": "f_insurer"
          },
          {
            "label": "Представитель страхователя",
            "field_id": "f_insurer_rep"
          },
          {
            "label": "Место осмотра",
            "field_id": "f_inspection_address"
          },
          {
            "label": "Описание события и причины",
            "field_id": "f_event_circumstances"
          },
          {
            "label": "Дата события",
            "field_id": "f_event_date"
          }
        ],
        "damage_item": {
          "title_parts": [
            "category",
            "element",
            "subelement"
          ],
          "fields_from_template": true,
          "photos_layout": {
            "columns": 2,
            "rows_per_page": 4,
            "max_photos": 10
          }
        }
      }
    },
    "ui": {
      "steps": [
        {
          "id": "step1",
          "title": "Анкета",
          "required_fields": [
            "f_insurer",
            "f_insurer_rep",
            "f_policy_number",
            "f_policy_date",
            "f_inspection_address",
            "f_event_circumstances",
            "f_event_date",
            "f_inspection_date"
          ]
        },
        {
          "id": "step2",
          "title": "Повреждения",
          "list_ref": "state.damage_items"
        },
        {
          "id": "step3",
          "title": "Добавление повреждения",
          "inventory_ref": "damage_item"
        },
        {
          "id": "step4",
          "title": "Финализация",
          "actions": [
            "export_pdf",
            "submit"
          ]
        }
      ]
    },
    "state_schema": {
      "damage_items": {
        "type": "array",
        "item": "damage_item"
      },
      "damage_item": {
        "fields": [
          "f_damage_category",
          "f_damage_element",
          "f_damage_subelement",
          "f_material",
          "f_view",
          "f_type",
          "f_texture",
          "f_details",
          "f_laminate_class",
          "f_window_material",
          "f_window_type",
          "f_window_size",
          "f_door_material",
          "f_door_type",
          "f_door_size",
          "f_glass_type",
          "f_cameras",
          "f_film_type",
          "f_glasspack_size",
          "f_glass_thickness_mm",
          "f_glass_formula",
          "f_facade_cladding",
          "f_facade_frame",
          "f_facade_insulation",
          "f_roof_view",
          "f_roof_covering",
          "f_roof_hydro",
          "f_roof_insulation",
          "f_roof_rafters_material",
          "f_gutter_material",
          "f_snowguards_type",
          "f_socle_finish",
          "f_damage_char",
          "f_damage_size",
          "f_room_size",
          "f_year_last_caprepair",
          "f_door_openings_count",
          "f_window_openings_count",
          "f_year_built",
          "f_furniture_name",
          "f_furniture_brand",
          "f_furniture_year",
          "f_furniture_info",
          "f_photos"
        ],
        "value_matching": {
          "select": "string_or_other_object_choice",
          "other_object_keys": {
            "choice": "choice",
            "other": "other"
          }
        }
      }
    }
  }
</textarea>

<script type="module">
  // ===============================
  // Utils (без innerHTML)
  // ===============================
  const $ = (id) => document.getElementById(id);

  function el(tag, props = {}, children = []) {
  const n = document.createElement(tag);

  for (const [k, v] of Object.entries(props)) {
    if (k === "class") {
      n.className = v || "";
      continue;
    }
    if (k === "text") {
      n.textContent = String(v ?? "");
      continue;
    }
    if (k === "value") {
      // важно: value задаём свойством, а не атрибутом
      n.value = (v ?? "");
      continue;
    }
    if (k.startsWith("on") && typeof v === "function") {
      n.addEventListener(k.slice(2), v);
      continue;
    }

    // ВАЖНО: boolean атрибуты (disabled, checked, required...) нельзя setAttribute("disabled","false")
    if (typeof v === "boolean") {
      n[k] = v; // свойство
      if (v) n.setAttribute(k, "");
      else n.removeAttribute(k);
      continue;
    }

    if (v != null) n.setAttribute(k, String(v));
  }

  for (const c of children) n.appendChild(c);
  return n;
}

  // ===============================
  // Sticky Footer helpers
  // ===============================
  const StickyFooter = (() => {
    const host = $("stickyFooter");
    const inner = $("stickyFooterInner");
    if (!host || !inner) return { set: () => {}, clear: () => {}, measure: () => {} };

    function measure() {
      // высоту футера складываем в CSS-переменную, чтобы .wrap знал, сколько “оставлять снизу”
      const h = host.offsetHeight || 0;
      document.documentElement.style.setProperty("--footerH", `${h}px`);
    }

    function clear() {
      inner.replaceChildren();
      host.style.display = "none";
      measure();
    }

    function set(node) {
      inner.replaceChildren(node);
      host.style.display = "";
      // после вставки — перемеряем
      requestAnimationFrame(measure);
    }

    window.addEventListener("resize", () => measure());
    return { set, clear, measure };
  })();

    // ===============================
  // Mobile keyboard detection (visualViewport)
  // ===============================
  function updateKeyboardState() {
    // Работает хорошо на мобильных (iOS/Android)
    const vv = window.visualViewport;
    if (!vv) return;

    // Когда клавиатура открылась, видимая высота (vv.height) сильно уменьшается
    const diff = window.innerHeight - vv.height;

    // Порог: подбираем так, чтобы не срабатывало от мелких “скачков”
    const isOpen = diff > 140;

    document.body.classList.toggle("kbdOpen", isOpen);

    // Когда футер в static — надо перемерить высоту/отступы
    StickyFooter.measure();
  }

  if (window.visualViewport) {
    window.visualViewport.addEventListener("resize", updateKeyboardState);
    window.visualViewport.addEventListener("scroll", updateKeyboardState);
  }

  // Фолбэк (если visualViewport нет)
  window.addEventListener("focusin", (e) => {
    const t = e.target;
    if (t && (t.tagName === "INPUT" || t.tagName === "TEXTAREA" || t.tagName === "SELECT")) {
      setTimeout(updateKeyboardState, 50);
    }
  });
  window.addEventListener("focusout", () => setTimeout(updateKeyboardState, 250));

  function safeClone(v) {
    if (typeof structuredClone === "function") return structuredClone(v);
    return JSON.parse(JSON.stringify(v));
  }

  function fmtDateRu(iso) {
    if (!iso || typeof iso !== "string") return "";
    const m = iso.match(/^(\d{4})-(\d{2})-(\d{2})$/);
    if (!m) return iso;
    return `${m[3]}.${m[2]}.${m[1]}`;
  }
  function downloadBlob(blob, fileName) {
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = fileName || "download.bin";
  document.body.appendChild(a);
  a.click();
  a.remove();
  setTimeout(() => URL.revokeObjectURL(url), 1500);
}
  // ===============================
  // Persistence (IndexedDB) — Phase1 local only
  //
  // DB: osmotrum_v55_local
  // Stores:
  //  - kv      : key-value для config и app_state
  //  - images  : фото (Blob) + метаданные (id = photoId)
  //  - pdf     : PDF (Blob) + метаданные (id = pdfId, обычно "last")
  //
  // ВАЖНО:
  //  - В state храним только ссылки на фото: photoId[]
  //  - Сами Blob'ы фото и PDF лежат в IndexedDB
  // ===============================
  const Persistence = (() => {
    const DB_NAME = "osmotrum_v55_local";
    const DB_VER = 2;

    const STORE_KV = "kv";
    const STORE_IMAGES = "images";
    const STORE_PDF = "pdf";

    let db = null;
    let timer = null;
    let saving = false;
    let lastQueued = null;

    const persistLine = () => document.getElementById("persistLine");

    function openDb() {
      return new Promise((resolve, reject) => {
        const req = indexedDB.open(DB_NAME, DB_VER);

        req.onupgradeneeded = () => {
          const d = req.result;

          // 1) kv
          if (!d.objectStoreNames.contains(STORE_KV)) d.createObjectStore(STORE_KV);

          // 2) images (photoId -> record)
          if (!d.objectStoreNames.contains(STORE_IMAGES)) {
            d.createObjectStore(STORE_IMAGES, { keyPath: "id" });
          }

          // 3) pdf (pdfId -> record)
          if (!d.objectStoreNames.contains(STORE_PDF)) {
            d.createObjectStore(STORE_PDF, { keyPath: "id" });
          }
        };

        req.onsuccess = () => resolve(req.result);
        req.onerror = () => reject(req.error);
      });
    }

    // ---------- low-level helpers ----------
    function txStore(storeName, mode = "readonly") {
      const tx = db.transaction(storeName, mode);
      return tx.objectStore(storeName);
    }

    function kvGet(key) {
      return new Promise((resolve, reject) => {
        if (!db) return resolve(null);
        const st = txStore(STORE_KV, "readonly");
        const req = st.get(key);
        req.onsuccess = () => resolve(req.result ?? null);
        req.onerror = () => reject(req.error);
      });
    }

    function kvPut(key, value) {
      return new Promise((resolve, reject) => {
        if (!db) return resolve();
        const st = txStore(STORE_KV, "readwrite");
        const req = st.put(value, key);
        req.onsuccess = () => resolve();
        req.onerror = () => reject(req.error);
      });
    }

    function storeGet(storeName, key) {
      return new Promise((resolve, reject) => {
        if (!db) return resolve(null);
        const st = txStore(storeName, "readonly");
        const req = st.get(key);
        req.onsuccess = () => resolve(req.result ?? null);
        req.onerror = () => reject(req.error);
      });
    }

    function storePut(storeName, value) {
      return new Promise((resolve, reject) => {
        if (!db) return resolve();
        const st = txStore(storeName, "readwrite");
        const req = st.put(value);
        req.onsuccess = () => resolve();
        req.onerror = () => reject(req.error);
      });
    }

    function storeDelete(storeName, key) {
      return new Promise((resolve, reject) => {
        if (!db) return resolve();
        const st = txStore(storeName, "readwrite");
        const req = st.delete(key);
        req.onsuccess = () => resolve();
        req.onerror = () => reject(req.error);
      });
    }

    function clearStore(storeName) {
      return new Promise((resolve, reject) => {
        if (!db) return resolve();
        const st = txStore(storeName, "readwrite");
        const req = st.clear();
        req.onsuccess = () => resolve();
        req.onerror = () => reject(req.error);
      });
    }

    // ---------- UI helper ----------
    function setPersistUi(text) {
      const n = persistLine();
      if (!n) return;
      n.textContent = text || "";
    }

    // ---------- app_state helpers ----------
    function toAppState(fullState) {
      return {
        stepId: fullState?.stepId ?? null,
        form: fullState?.form ?? {},
        damage_items: Array.isArray(fullState?.damage_items) ? fullState.damage_items : [],
        current_damage_index: fullState?.current_damage_index ?? null,
      };
    }

    function normalizeAppState(app) {
      return {
        stepId: app?.stepId ?? null,
        form: (app?.form && typeof app.form === "object") ? app.form : {},
        damage_items: Array.isArray(app?.damage_items) ? app.damage_items : [],
        current_damage_index: (Number.isInteger(app?.current_damage_index) ? app.current_damage_index : null),
      };
    }

    // ---------- ids ----------
    function makeId(prefix = "id") {
      if (crypto?.randomUUID) return `${prefix}_${crypto.randomUUID()}`;
      return `${prefix}_${Date.now()}_${Math.random().toString(16).slice(2)}`;
    }

    // ---------- public API ----------
    async function init() {
      db = await openDb();
      return true;
    }

    async function load() {
      const [cfg, app] = await Promise.all([kvGet("config"), kvGet("app_state")]);
      return {
        config: (cfg && typeof cfg === "object") ? cfg : null,
        app: normalizeAppState(app),
      };
    }

    async function saveConfig(cfg) {
      if (!cfg || typeof cfg !== "object") return;
      await kvPut("config", cfg);
    }

    function scheduleSave(fullState) {
      lastQueued = toAppState(fullState);
      setPersistUi("Сохраняю…");

      if (timer) clearTimeout(timer);
      timer = setTimeout(async () => {
        if (saving) return;
        saving = true;
        try {
          const payload = lastQueued
            ? safeClone(lastQueued)
            : { stepId:null, form:{}, damage_items:[], current_damage_index:null };

          await kvPut("app_state", payload);
          setPersistUi("Сохранено");
        } catch (e) {
          console.error("IDB save error", e);
          setPersistUi("Ошибка сохранения (см. консоль)");
        } finally {
          saving = false;
        }
      }, 300);
    }

    // ---- images (Blob) ----
    async function saveImageRecord({ blob, mime, width, height, sourceName = "" }) {
      const id = makeId("photo");
      const rec = {
        id,
        blob,
        mime: mime || blob?.type || "image/jpeg",
        width: Number.isFinite(width) ? width : null,
        height: Number.isFinite(height) ? height : null,
        bytes: blob?.size ?? null,
        sourceName: String(sourceName || ""),
        createdAt: new Date().toISOString(),
      };
      await storePut(STORE_IMAGES, rec);
      return id;
    }

    async function getImageRecord(photoId) {
      if (!photoId) return null;
      return await storeGet(STORE_IMAGES, photoId);
    }

    async function deleteImageRecord(photoId) {
      if (!photoId) return;
      await storeDelete(STORE_IMAGES, photoId);
    }

    // ---- pdf (Blob) ----
    async function savePdfRecord({ blob, pdfId = "last", fileName = "" }) {
      const rec = {
        id: String(pdfId || "last"),
        blob,
        bytes: blob?.size ?? null,
        fileName: String(fileName || ""),
        createdAt: new Date().toISOString(),
      };
      await storePut(STORE_PDF, rec);
      return rec.id;
    }

    async function getPdfRecord(pdfId = "last") {
      return await storeGet(STORE_PDF, String(pdfId || "last"));
    }

    async function clearInspectionData() {
  // остановить отложенное сохранение, чтобы старое состояние не записалось поверх очищенного
  if (timer) { clearTimeout(timer); timer = null; }
  lastQueued = null;

  // чистим вложения
  await Promise.all([
    clearStore(STORE_IMAGES),
    clearStore(STORE_PDF),
  ]);

  // сбрасываем только данные осмотра (config не трогаем)
  await kvPut("app_state", {
    stepId: null,
    form: {},
    damage_items: [],
    current_damage_index: null,
  });

  setPersistUi("");
}

    async function clearAll() {
      try {
        await Promise.all([
          clearStore(STORE_KV),
          clearStore(STORE_IMAGES),
          clearStore(STORE_PDF),
        ]);
        setPersistUi("");
      } catch (e) {
        console.error("IDB clearAll error", e);
      }
    }

    return {
      init, load, saveConfig, scheduleSave, clearInspectionData, clearAll,
      // images
      saveImageRecord, getImageRecord, deleteImageRecord,
      // pdf
      savePdfRecord, getPdfRecord,
    };
  })();

// ===============================
// Image Adapter (inline from image-adapter.js)
// ===============================
function createImageAdapter() {
  let worker = null;
  let initialized = false;
  let initPromise = null;

  const pending = new Map(); // requestId -> {resolve,reject,timer}

  let seq = 1;
  const DEFAULT_PROCESS_TIMEOUT_MS = 20000;

  function makeWorker() {
    const url = new URL("./img-worker.js", import.meta.url);
    const w = new Worker(url);

    w.addEventListener("message", (ev) => {
      const msg = ev.data || {};
      const type = msg.type;

      if (type === "init_ok" && msg.ok) return;

      const rid = msg.requestId || msg.request_id || msg.rid || msg.id || null;
      if (!rid) return;

      const p = pending.get(rid);
      if (!p) return;

      clearTimeout(p.timer);
      pending.delete(rid);

      const ok = (msg.ok === true) || (msg.success === true) || (type === "process_ok") || (type === "process_done");
      if (!ok) {
        p.reject(msg.error || { code: "E_WORKER", message: "Worker returned not ok" });
        return;
      }

      try {
        const payload = normalizeProcessPayload(msg);
        p.resolve(payload);
      } catch (e) {
        p.reject({ code: "E_ADAPTER_PAYLOAD", message: String(e?.message || e) });
      }
    });

    w.addEventListener("messageerror", (e) => {
      console.error("img-worker messageerror:", e);
    });

    w.addEventListener("error", (e) => {
      for (const [rid, p] of pending.entries()) {
        clearTimeout(p.timer);
        p.reject({ code: "E_WORKER_CRASH", message: String(e?.message || e) });
        pending.delete(rid);
      }
    });

    return w;
  }

  function toBlobMaybe(part) {
    if (!part) return part;

    if (part instanceof Blob) {
      return { blob: part, mime: part.type || "application/octet-stream", bytes: part.size };
    }

    if (part.blob instanceof Blob) {
      return {
        ...part,
        mime: part.mime || part.blob.type || "application/octet-stream",
        bytes: typeof part.bytes === "number" ? part.bytes : part.blob.size
      };
    }

    const mime = part.mime || part.type || "application/octet-stream";
    const data =
      part.data ||
      part.buffer ||
      part.arrayBuffer ||
      part.u8 ||
      part.uint8 ||
      part.bytes_data ||
      null;

    if (data instanceof ArrayBuffer) {
      const b = new Blob([data], { type: mime });
      return { ...part, blob: b, mime, bytes: b.size };
    }

    if (data && typeof data === "object" && data.buffer instanceof ArrayBuffer) {
      const u8 = (data instanceof Uint8Array) ? data : new Uint8Array(data.buffer);
      const b = new Blob([u8], { type: mime });
      return { ...part, blob: b, mime, bytes: b.size };
    }

    if (part instanceof ArrayBuffer) {
      const b = new Blob([part], { type: mime });
      return { blob: b, mime, bytes: b.size };
    }

    return part;
  }

  function normalizeProcessPayload(msg) {
    const original =
      msg.original ??
      msg.original_image ??
      msg.originalData ??
      (msg.original_blob ? { blob: msg.original_blob, mime: msg.original_mime, bytes: msg.original_bytes } : null);

    const normalized =
      msg.normalized ??
      msg.normalized_image ??
      msg.output ??
      msg.jpeg ??
      msg.normalizedData ??
      (msg.normalized_blob ? { blob: msg.normalized_blob, mime: msg.normalized_mime, bytes: msg.normalized_bytes } : null);

    const out = {
      original: toBlobMaybe(original),
      normalized: toBlobMaybe(normalized),
      debug: msg.debug || msg.runtime || null
    };

    if (!out.normalized || !(out.normalized.blob instanceof Blob)) {
      throw new Error("Worker did not provide normalized.blob (Blob). Check img-worker output format.");
    }
    return out;
  }

  async function init(config) {
    if (initialized) return;
    if (initPromise) return initPromise;

    initPromise = new Promise((resolve, reject) => {
      try {
        if (worker) worker.terminate();
        worker = makeWorker();

        const onInitMessage = (ev) => {
          const msg = ev.data || {};
          if (msg.type === "init_ok" && msg.ok) {
            initialized = true;
            worker.removeEventListener("message", onInitMessage);
            resolve(msg.runtime || null);
          }
        };

        worker.addEventListener("message", onInitMessage);
        worker.postMessage({ type: "init", config });
      } catch (e) {
        reject(e);
      }
    });

    return initPromise;
  }

  async function processFile({ file, photoId, timeoutMs = DEFAULT_PROCESS_TIMEOUT_MS }) {
    if (!worker || !initialized) throw new Error("Adapter not initialized. Call init(config) first.");
    if (!file) throw new Error("No file provided");

    const requestId = "r" + (seq++);

    const p = new Promise((resolve, reject) => {
      const timer = setTimeout(() => {
        pending.delete(requestId);
        reject({ code: "E_WORKER_TIMEOUT", message: `No response from img-worker within ${timeoutMs}ms` });
      }, timeoutMs);

      pending.set(requestId, { resolve, reject, timer });
      worker.postMessage({ type: "process", requestId, file });
    });

    const payload = await p;
    payload.photoId = photoId;
    return payload;
  }

  function close() {
    if (worker) worker.terminate();
    worker = null;
    initialized = false;
    initPromise = null;

    for (const [rid, p] of pending.entries()) {
      clearTimeout(p.timer);
      pending.delete(rid);
    }
  }

  return { init, processFile, close };
}

function formatErr(e) {
  if (!e) return "Unknown error";
  if (typeof e === "string") return e;
  if (e.message) return e.message;
  if (e.code) return `${e.code}${e.details ? ": " + JSON.stringify(e.details) : ""}`;
  try { return JSON.stringify(e); } catch { return String(e); }
}

// ===============================
// Image Pipeline (IDB images + thumbs)
// ===============================
const ImagePipeline = (() => {
  const adapter = createImageAdapter();
  const thumbUrlById = new Map(); // photoId -> objectURL
  let ready = false;
  let initPromise = null;

  async function init(cfg) {
    if (ready) return;
    if (initPromise) return initPromise;

    initPromise = (async () => {
      await adapter.init(cfg);
      ready = true;
      return true;
    })();

    return initPromise;
  }

  function clearThumbs() {
    for (const url of thumbUrlById.values()) {
      try { URL.revokeObjectURL(url); } catch {}
    }
    thumbUrlById.clear();
  }

  async function saveNormalizedBlobToIdb({ blob, mime, width, height, sourceName }) {
    const photoId = await Persistence.saveImageRecord({ blob, mime, width, height, sourceName });
    // сразу делаем превью, чтобы не читать назад из IDB
    const url = URL.createObjectURL(blob);
    thumbUrlById.set(photoId, url);
    return photoId;
  }

  async function getThumbUrl(photoId) {
    if (!photoId) return null;
    if (thumbUrlById.has(photoId)) return thumbUrlById.get(photoId);

    const rec = await Persistence.getImageRecord(photoId);
    if (!rec?.blob) return null;

    const url = URL.createObjectURL(rec.blob);
    thumbUrlById.set(photoId, url);
    return url;
  }

  function revoke(photoId) {
    const url = thumbUrlById.get(photoId);
    if (url) {
      try { URL.revokeObjectURL(url); } catch {}
      thumbUrlById.delete(photoId);
    }
  }

  async function processAndStoreFiles({ cfg, files, onProgress }) {
    if (!ready) await init(cfg);

    const list = Array.from(files || []);
    const outIds = [];
    let done = 0;

    for (const file of list) {
      try {
        const r = await adapter.processFile({ file, photoId: "tmp", timeoutMs: 120000 });
        const photoId = await saveNormalizedBlobToIdb({
          blob: r.normalized.blob,
          mime: r.normalized.mime || "image/jpeg",
          width: r.normalized.width,
          height: r.normalized.height,
          sourceName: file.name
        });
        outIds.push(photoId);
      } catch (e) {
        throw { code: "E_PHOTO_ADD", message: `Не удалось обработать "${file?.name || "файл"}": ${formatErr(e)}` };
      } finally {
        done++;
        if (typeof onProgress === "function") onProgress(done, list.length);
      }
    }

    return outIds;
  }

  return { init, clearThumbs, getThumbUrl, revoke, processAndStoreFiles };
})();

/* rules-engine.js
 * Schema-driven rules engine for damage_item (Config.DB v5.5).
 * Key fixes:
 *  - template-aware applicability: skip rules that reference fields not present in current template
 *    (except selector fields category/element/subelement).
 *  - set_visibility_and_required: DO NOT reset dictionary_id in else branch when just toggling visibility.
 *
 * Exports:
 *  - createRulesEngine(config)
 */


 const ALLOWED_ACTION_TYPES = new Set([
  "set_dictionary",
  "set_dictionary_and_visibility",
  "set_visibility_and_required",
  "set_field_visibility_dictionary_required",
  "clear_fields",
]);

function stableStringify(v) {
  try { return JSON.stringify(v); } catch { return String(v); }
}

function deepClone(obj) {
  if (typeof structuredClone === "function") return structuredClone(obj);
  return JSON.parse(JSON.stringify(obj ?? {}));
}

function isFieldId(config, id) {
  return Array.isArray(config?.fields) && config.fields.some(f => f.id === id);
}

function hasDictionary(config, id) {
  return Array.isArray(config?.dictionaries) && config.dictionaries.some(d => d.id === id);
}

function getSelectors(config) {
  const sel = config?.inventory?.damage_item?.selectors;
  if (!sel?.category?.field_id || !sel?.element?.field_id || !sel?.subelement?.field_id) return null;
  return {
    categoryFieldId: sel.category.field_id,
    elementFieldId: sel.element.field_id,
    subelementFieldId: sel.subelement.field_id,
  };
}

function diffChangedFieldIds(prevItem, nextItem) {
  const prev = prevItem || {};
  const next = nextItem || {};
  const keys = new Set([...Object.keys(prev), ...Object.keys(next)]);
  const changed = [];
  for (const k of keys) {
    if (stableStringify(prev[k]) !== stableStringify(next[k])) changed.push(k);
  }
  return changed;
}

/** Match current template by selectors (category/element/subelement).
 * Chooses most specific match:
 *  - category+element+subelement (3)
 *  - category+element (2) when template.when.subelement is null
 *  - category only (1) if such templates exist (rare)
 * Stable by order in config (first wins on tie).
 */
function matchDamageTemplate(config, selectors, damageItem) {
  const templates = config?.inventory?.damage_item?.templates || [];
  const item = damageItem || {};

  const cat = item[selectors.categoryFieldId];
  const el  = item[selectors.elementFieldId];
  const sub = item[selectors.subelementFieldId];

  let best = null;
  let bestScore = -1;

  for (const t of templates) {
    const w = t?.when || {};
    if (!w.category || w.category !== cat) continue;

    // element match
    if (w.element != null && w.element !== el) continue;

    // subelement match
    if (w.subelement != null && w.subelement !== sub) continue;

    let score = 1;
    if (w.element != null) score++;
    if (w.subelement != null) score++;

    if (score > bestScore) {
      best = t;
      bestScore = score;
    }
  }

  return best;
}

// Condition evaluation for config "if" objects:
// - { value: "..." } compares to rule.when.field
// - { category:"...", element:"...", subelement:"...", view:"...", material:"..." } compares to resolved field_ids
function makeConditionMatcher(config, selectors, ruleWhen) {
  const whenFields = [];
  if (ruleWhen?.field) whenFields.push(ruleWhen.field);
  if (Array.isArray(ruleWhen?.fields)) whenFields.push(...ruleWhen.fields);

  // normalize {choice, other} -> choice for comparisons inside rules
  const otherKeys = config?.state_schema?.damage_item?.value_matching?.other_object_keys || {};
  const CHOICE_KEY = otherKeys.choice || "choice";

  const norm = (v) => {
    if (v && typeof v === "object" && Object.prototype.hasOwnProperty.call(v, CHOICE_KEY)) {
      return v[CHOICE_KEY];
    }
    return v;
  };

  function prefer(candidates) {
    for (const c of candidates) if (whenFields.includes(c)) return c;
    for (const c of candidates) if (isFieldId(config, c)) return c;
    return null;
  }

  function resolveSemanticFieldId(key) {
    if (key === "category") return selectors.categoryFieldId;
    if (key === "element") return selectors.elementFieldId;
    if (key === "subelement") return selectors.subelementFieldId;
    if (key === "view") return prefer(["f_view"]);
    if (key === "material") return prefer(["f_door_material", "f_window_material", "f_material"]);
    return null;
  }

  function matchesIfObject(damageItem, ifObj) {
    const item = damageItem || {};
    if (!ifObj || typeof ifObj !== "object") return false;

    // Special: {value:"..."} matches on the trigger field
    if ("value" in ifObj) {
      const trigger = ruleWhen?.field
        || (Array.isArray(ruleWhen?.fields) && ruleWhen.fields.length === 1 ? ruleWhen.fields[0] : null);
      if (!trigger) return false;
      return stableStringify(norm(item[trigger])) === stableStringify(ifObj.value);
    }

    for (const [k, expected] of Object.entries(ifObj)) {
      const fieldId = resolveSemanticFieldId(k);
      if (!fieldId) return false;
      if (stableStringify(norm(item[fieldId])) !== stableStringify(expected)) return false;
    }
    return true;
  }

  return { matchesIfObject };
}

function createRulesEngine(config) {
  const cfg = config || {};
  const selectors = getSelectors(cfg);

  const selectorSet = selectors
    ? new Set([selectors.categoryFieldId, selectors.elementFieldId, selectors.subelementFieldId])
    : new Set();

  function validateConfig() {
    const errors = [];
    const rules = cfg?.rules || [];

    if (!selectors) {
      errors.push(`inventory.damage_item.selectors is missing/invalid (category/element/subelement.field_id required).`);
      return errors;
    }

    const ids = new Set();
    for (const r of rules) {
      if (!r?.id) errors.push(`Rule without id found.`);
      else {
        if (ids.has(r.id)) errors.push(`Duplicate rule.id: ${r.id}`);
        ids.add(r.id);
      }

      const when = r?.when || {};
      const whenFields = [];
      if (when.field) whenFields.push(when.field);
      if (Array.isArray(when.fields)) whenFields.push(...when.fields);
      if (whenFields.length === 0) errors.push(`Rule ${r.id}: when.field/when.fields missing.`);

      for (const wf of whenFields) {
        if (!isFieldId(cfg, wf)) errors.push(`Rule ${r.id}: when references unknown field_id ${wf}`);
      }

      const actions = Array.isArray(r.actions) ? r.actions : [];
      for (const a of actions) {
        if (!ALLOWED_ACTION_TYPES.has(a?.type)) {
          errors.push(`Rule ${r.id}: unknown action.type "${a?.type}"`);
          continue;
        }

        if (a.type === "set_dictionary") {
          if (!isFieldId(cfg, a.field_id)) errors.push(`Rule ${r.id}: set_dictionary unknown field_id ${a.field_id}`);
          const byv = a.by_value || {};
          for (const dictId of Object.values(byv)) if (dictId && !hasDictionary(cfg, dictId)) errors.push(`Rule ${r.id}: set_dictionary unknown dictionary_id ${dictId}`);
        }

        if (a.type === "set_dictionary_and_visibility") {
          if (!isFieldId(cfg, a.field_id)) errors.push(`Rule ${r.id}: set_dictionary_and_visibility unknown field_id ${a.field_id}`);
          for (const c of (a.cases || [])) if (c.dictionary_id && !hasDictionary(cfg, c.dictionary_id)) errors.push(`Rule ${r.id}: unknown dictionary_id ${c.dictionary_id}`);
          if (a.default?.dictionary_id && !hasDictionary(cfg, a.default.dictionary_id)) errors.push(`Rule ${r.id}: unknown dictionary_id ${a.default.dictionary_id}`);
        }

        if (a.type === "set_visibility_and_required") {
          for (const fid of (a.field_ids || [])) if (!isFieldId(cfg, fid)) errors.push(`Rule ${r.id}: set_visibility_and_required unknown field_id ${fid}`);
          const dov = a.dictionary_overrides || {};
          for (const [fid, dictId] of Object.entries(dov)) {
            if (!isFieldId(cfg, fid)) errors.push(`Rule ${r.id}: dictionary_overrides unknown field_id ${fid}`);
            if (dictId && !hasDictionary(cfg, dictId)) errors.push(`Rule ${r.id}: dictionary_overrides unknown dictionary_id ${dictId}`);
          }
        }

        if (a.type === "set_field_visibility_dictionary_required") {
          for (const c of (a.cases || [])) {
            for (const sh of (c.show || [])) {
              if (!isFieldId(cfg, sh.field_id)) errors.push(`Rule ${r.id}: show unknown field_id ${sh.field_id}`);
              if (sh.dictionary_id && !hasDictionary(cfg, sh.dictionary_id)) errors.push(`Rule ${r.id}: show unknown dictionary_id ${sh.dictionary_id}`);
            }
            for (const hid of (c.hide || [])) if (!isFieldId(cfg, hid)) errors.push(`Rule ${r.id}: hide unknown field_id ${hid}`);
          }
          for (const hid of (a.default?.hide || [])) if (!isFieldId(cfg, hid)) errors.push(`Rule ${r.id}: default.hide unknown field_id ${hid}`);
        }

        if (a.type === "clear_fields") {
          for (const fid of (a.field_ids || [])) if (!isFieldId(cfg, fid)) errors.push(`Rule ${r.id}: clear_fields unknown field_id ${fid}`);
        }
      }
    }

    return errors;
  }

  function initRuntime() {
    return { fields: {}, debug: { applied: [] } };
  }

  function setFieldRuntime(rt, fieldId, patch) {
    if (!rt.fields[fieldId]) rt.fields[fieldId] = {};
    Object.assign(rt.fields[fieldId], patch);
  }

  function clearField(item, fieldId) {
    if (item && Object.prototype.hasOwnProperty.call(item, fieldId)) delete item[fieldId];
  }

  function applyRules({ prevItem, nextItem }) {
    const prev = prevItem || {};
    const nextOriginal = nextItem || {};
    const next = deepClone(nextOriginal);

    const changed = diffChangedFieldIds(prev, nextOriginal);
    const changedSet = new Set(changed);

    const rt = initRuntime();
    const rules = cfg?.rules || [];

    // Determine current template (if selectors are present)
    const tmpl = selectors ? matchDamageTemplate(cfg, selectors, next) : null;
    const tmplFieldSet = new Set((tmpl?.fields || []).map(f => f.field_id));

    for (const rule of rules) {
      const when = rule?.when || {};
      const triggerFields = [];
      if (when.field) triggerFields.push(when.field);
      if (Array.isArray(when.fields)) triggerFields.push(...when.fields);

      // Template-aware applicability:
      // Skip rule if it references a non-selector trigger that is NOT present in current template.
      // (This prevents "door" rules affecting "window" templates, and "sheathing" rules affecting "cladding" templates.)
      if (tmpl) {
        const nonSelectorTriggers = triggerFields.filter(f => !selectorSet.has(f));
        const hasAllInTemplate = nonSelectorTriggers.every(f => tmplFieldSet.has(f));
        if (!hasAllInTemplate) {
          rt.debug.applied.push({ rule: rule.id, skipped: true, reason: "trigger_not_in_template", template: tmpl.id });
          continue;
        }
      }

      const shouldRunClears = triggerFields.some(f => changedSet.has(f));
      const { matchesIfObject } = makeConditionMatcher(cfg, selectors, when);

      for (const action of (rule.actions || [])) {
        const t = String(action.type || "").trim();

        // 1) set_dictionary
        if (t === "set_dictionary") {
          const triggerField = when.field;
          const val = triggerField ? next[triggerField] : undefined;

          const dictId =
            (action.by_value && Object.prototype.hasOwnProperty.call(action.by_value, val))
              ? action.by_value[val]
              : action.else;

          setFieldRuntime(rt, action.field_id, { dictionary_id: dictId ?? null });
          rt.debug.applied.push({ rule: rule.id, action: t, field_id: action.field_id, dictionary_id: dictId ?? null });
          continue;
        }

        // 2) set_dictionary_and_visibility
        if (t === "set_dictionary_and_visibility") {
          let matchedCase = null;
          for (const c of (action.cases || [])) {
            if (matchesIfObject(next, c.if)) { matchedCase = c; break; }
          }

          const out = matchedCase
            ? { visible: !!matchedCase.visible, required: !!matchedCase.required, dictionary_id: matchedCase.dictionary_id ?? null, clear: false }
            : { visible: !!action.default?.visible, required: !!action.default?.required, dictionary_id: action.default?.dictionary_id ?? null, clear: !!action.default?.clear };

          setFieldRuntime(rt, action.field_id, { visible: out.visible, required: out.required, dictionary_id: out.dictionary_id });
          rt.debug.applied.push({ rule: rule.id, action: t, field_id: action.field_id, ...out });

          if (shouldRunClears && out.clear) clearField(next, action.field_id);
          continue;
        }

        // 3) set_visibility_and_required
        if (t === "set_visibility_and_required") {
          const isMatch = matchesIfObject(next, action.if);
          const fieldIds = action.field_ids || [];

          if (isMatch) {
            for (const fid of fieldIds) {
              const req = Array.isArray(action.required_fields)
                ? action.required_fields.includes(fid)
                : (typeof action.if_required === "boolean" ? action.if_required : false);

              setFieldRuntime(rt, fid, { visible: !!action.visible, required: !!req });
            }

            // dictionary overrides only on match
            for (const [fid, dictId] of Object.entries(action.dictionary_overrides || {})) {
              setFieldRuntime(rt, fid, { dictionary_id: dictId ?? null });
            }

            rt.debug.applied.push({ rule: rule.id, action: t, branch: "if", matched: true });
          } else {
            const elseObj = action.else || {};
            // SCOPE GUARD:
// If action.if is scoped by selectors (category+element and/or subelement),
// do NOT apply else branch outside that selector scope.
// This prevents cross-category rules from hiding the same fields
// (example: room-door vs glazing-door glass blocks both target f_glass_*).
const ifObj = action.if || {};
const scopeKeys = ["category", "element", "subelement"]
  .filter(k => Object.prototype.hasOwnProperty.call(ifObj, k));

if (scopeKeys.length >= 2) {
  const scopeIf = {};
  for (const k of scopeKeys) scopeIf[k] = ifObj[k];
  const inScope = matchesIfObject(next, scopeIf);
  if (!inScope) {
    rt.debug.applied.push({ rule: rule.id, action: t, branch: "else-skip-scope", matched: false });
    continue;
  }
}
            const vis = ("visible" in elseObj) ? !!elseObj.visible : false;
            const req = (typeof action.else_required === "boolean") ? action.else_required : false;

            for (const fid of fieldIds) {
              // IMPORTANT: do NOT reset dictionary_id here unless we are hiding+clearing.
              setFieldRuntime(rt, fid, { visible: vis, required: !!req });

              if (shouldRunClears && !vis && elseObj.clear) {
                clearField(next, fid);
                setFieldRuntime(rt, fid, { dictionary_id: null });
              }
            }

            rt.debug.applied.push({ rule: rule.id, action: t, branch: "else", matched: false });
          }

          continue;
        }

        // 4) set_field_visibility_dictionary_required
        if (t === "set_field_visibility_dictionary_required") {
          const cases = Array.isArray(action.cases) ? action.cases : [];

          let matched = null;
          for (const c of cases) {
            if (matchesIfObject(next, c.if)) { matched = c; break; }
          }


          // scope = общие (одинаковые) пары ключ/значение, которые встречаются во ВСЕХ cases[].if
          // Нужно, чтобы default не применялся "где попало".
          const computeCommonScope = (casesArr) => {
            if (!casesArr.length) return null;
            const firstIf = casesArr[0]?.if;
            if (!firstIf || typeof firstIf !== "object") return null;

            const scope = {};
            for (const [k, v] of Object.entries(firstIf)) {
              let ok = true;
              for (const c of casesArr) {
                const ci = c?.if;
                if (!ci || typeof ci !== "object" || !(k in ci) || stableStringify(ci[k]) !== stableStringify(v)) {
                  ok = false;
                  break;
                }
              }
              if (ok) scope[k] = v;
            }
            return scope;
          };

          let branch = null;
          let branchLabel = "";

          if (matched) {
            branch = matched;
            branchLabel = "case";
          } else if (action.default) {
            const scope = computeCommonScope(cases);
            const scopeKeys = scope ? Object.keys(scope) : [];

            // Если scope пустой/непонятный — сохраняем старое поведение (default применяем)
            if (!scope || scopeKeys.length === 0) {
              branch = action.default;
              branchLabel = "default";
            } else if (matchesIfObject(next, scope)) {
              // default применяем только если мы "в контексте" этих cases
              branch = action.default;
              branchLabel = "default";
            } else {
              // ВНЕ scope — не трогаем поля вообще
              rt.debug.applied.push({ rule: rule.id, action: t, skipped: true, reason: "default_out_of_scope" });
              continue;
            }
          } else {
            rt.debug.applied.push({ rule: rule.id, action: t, skipped: true, reason: "no_match_no_default" });
            continue;
          }

          for (const sh of (branch.show || [])) {
            setFieldRuntime(rt, sh.field_id, {
              visible: true,
              required: !!sh.required,
              dictionary_id: sh.dictionary_id ?? null
            });
          }

          for (const hid of (branch.hide || [])) {
            setFieldRuntime(rt, hid, { visible: false, required: false, dictionary_id: null });
            if (shouldRunClears) clearField(next, hid);
          }

          rt.debug.applied.push({ rule: rule.id, action: t, branch: branchLabel });
          continue;
        }
// 5) clear_fields
if (t === "clear_fields") {
  if (!shouldRunClears) continue;

  const okToClear = action.if ? matchesIfObject(next, action.if) : true;
  if (!okToClear) continue;

  for (const fid of (action.field_ids || [])) clearField(next, fid);

  rt.debug.applied.push({
    rule: rule.id,
    action: t,
    cleared: action.field_ids || []
  });

  continue;
}

        throw new Error(`Unknown action.type at runtime: ${t}`);
      }
    }

    return { runtime: rt, nextItem: next, changedFieldIds: changed };
  }

  return { validateConfig, applyRules };
}

let __rulesEngine = null;
let __rulesErrors = [];

function initRulesEngine(cfg) {
  try {
    __rulesEngine = createRulesEngine(cfg);
    __rulesErrors = __rulesEngine.validateConfig();
  } catch (e) {
    __rulesEngine = null;
    __rulesErrors = [String(e?.message || e)];
  }
}

  // ===============================
  // Store (однонаправленный поток)
  // UI -> store.update -> render
  // ===============================
  const Store = (() => {
    let state = Object.freeze({
      config: null,
      stepId: null,
      // step1 data lives here (анкета)
      form: {},
      // step2 list
      damage_items: [],
      // step3 selection (пока заглушка)
      current_damage_index: null,
    });

    const listeners = new Set();

    function get() { return state; }

    function set(next, { skipRender = false } = {}) {
      state = Object.freeze(next);
      // Persist regardless of render (Step1 uses skipRender to keep focus)
      try { if (state?.config) Persistence.scheduleSave(state); } catch (e) { /* ignore */ }
      if (!skipRender) listeners.forEach(fn => fn(state));
    }

    function update(mutator, opts) {
      const draft = safeClone(state);
      mutator(draft);
      set(draft, opts);
    }

    function subscribe(fn) {
      listeners.add(fn);
      return () => listeners.delete(fn);
    }

    return { get, set, update, subscribe };
  })();

  // ===============================
  // Config loader (без fetch)
  // ===============================
  async function readJsonFile(file) {
    const text = await file.text();
    return JSON.parse(text);
  }

  function validateConfigBasic(cfg) {
    const errs = [];
    if (!cfg || typeof cfg !== "object") errs.push("config not an object");
    if (!cfg.meta) errs.push("missing meta");
    if (!Array.isArray(cfg.fields)) errs.push("missing fields[]");
    if (!cfg.ui || !Array.isArray(cfg.ui.steps)) errs.push("missing ui.steps[]");

    // minimal check: шаги должны иметь id и title
    for (const s of (cfg.ui?.steps || [])) {
      if (!s?.id) errs.push("ui.steps[]: step without id");
      if (!s?.title) errs.push(`ui.steps[]: step ${s?.id || "?"} without title`);
    }
    return errs;
  }

  function indexFieldsById(cfg) {
    const map = new Map();
    for (const f of (cfg.fields || [])) map.set(f.id, f);
    return map;
  }

  // ===============================
  // Rendering
  // ===============================
  function setStatus(text, kind = "muted") {
    const n = $("statusLine");
    n.className = kind === "err" ? "err" : kind === "ok" ? "ok" : "muted";
    n.textContent = text;
  }
    // ===============================
  // Hidden debug mode (7 taps on "Анкета" in stepper)
  // ===============================
  const DebugMode = (() => {
    const KEY = "osmotrum.debug";
    let enabled = false;

    try { enabled = localStorage.getItem(KEY) === "1"; } catch {}

    function isEnabled() { return enabled; }

    function set(v) {
      enabled = !!v;
      try { localStorage.setItem(KEY, enabled ? "1" : "0"); } catch {}
    }

    function toggle() {
      const next = !enabled;
      set(next);
      setStatus(next ? "Режим диагностики включён." : "Режим диагностики выключен.", next ? "ok" : "muted");
      render(); // перерисовать UI, чтобы показать/скрыть блок диагностики
    }

    return { isEnabled, toggle };
  })();

  const DebugUnlock = (() => {
    let taps = 0;
    let lastTs = 0;

    const NEED = 7;
    const GAP_MS = 1200; // если пауза между тапами > 1.2с — начинаем заново

    function tap() {
      const now = Date.now();
      if (now - lastTs > GAP_MS) taps = 0;
      lastTs = now;

      taps += 1;
      if (taps >= NEED) {
        taps = 0;
        DebugMode.toggle();
      }
    }

    return { tap };
  })();

  // ===============================
  // Stepper guards (чтобы нельзя было прыгать вперёд без валидности)
  // ===============================
  const StepGuards = {
    canNextByStepId: Object.create(null) // step1/step3 заполняют сюда true/false
  };

  // 4.3.1 UI-only validation state (НЕ сохраняется в IndexedDB)
  const UIValidation = (() => {
    const step1 = { attempted: false, touched: new Set() };
    const step3 = { attemptedByDamageId: new Set(), touchedByDamageId: new Map() };

    function getStep3TouchedSet(damageId) {
      if (!damageId) return new Set();
      let s = step3.touchedByDamageId.get(damageId);
      if (!s) { s = new Set(); step3.touchedByDamageId.set(damageId, s); }
      return s;
    }

    return {
      // попытка перейти вперёд
      markAttempt(stepId, damageId) {
        if (stepId === "step1") step1.attempted = true;
        if (stepId === "step3" && damageId) step3.attemptedByDamageId.add(damageId);
      },
      clearAttemptIfValid(stepId, damageId, isValid) {
        if (!isValid) return;
        if (stepId === "step1") step1.attempted = false;
        if (stepId === "step3" && damageId) step3.attemptedByDamageId.delete(damageId);
      },

      // пользователь "потрогал" поле (blur/click)
      markTouched(stepId, fieldId, damageId) {
        if (!fieldId) return;
        if (stepId === "step1") step1.touched.add(fieldId);
        if (stepId === "step3" && damageId) getStep3TouchedSet(damageId).add(fieldId);
      },

      // чтение флагов
      isAttempted(stepId, damageId) {
        if (stepId === "step1") return step1.attempted;
        if (stepId === "step3" && damageId) return step3.attemptedByDamageId.has(damageId);
        return false;
      },
      isTouched(stepId, fieldId, damageId) {
        if (!fieldId) return false;
        if (stepId === "step1") return step1.touched.has(fieldId);
        if (stepId === "step3" && damageId) return getStep3TouchedSet(damageId).has(fieldId);
        return false;
      },
    };
  })();

  function refreshStepperAvailability() {
    const st = Store.get();
    const cfg = st?.config;
    if (!cfg?.ui?.steps) return;

    const steps = cfg.ui.steps;
    const curIdx = steps.findIndex(s => s.id === st.stepId);
    if (curIdx < 0) return;

    const btns = Array.from(document.querySelectorAll("#steps .stepBtn"));

    // по умолчанию считаем шаг “валидным”, если guard не задан
    const canNext = (StepGuards.canNextByStepId[st.stepId] !== false);

    btns.forEach((b, i) => {
      if (i <= curIdx) b.disabled = false;               // назад всегда можно
      else if (i === curIdx + 1) b.disabled = !canNext;  // вперёд только на 1 шаг и только если валидно
      else b.disabled = true;                             // нельзя перепрыгивать через шаги
    });
  }

  function render() {
    const st = Store.get();
    const screen = $("screen");
    screen.replaceChildren();

    StickyFooter.clear();
    updateKeyboardState();

    // Debug (показываем только в режиме диагностики)
    const dbgOn = DebugMode.isEnabled();
    const dbgCard = $("debugCard");
    if (dbgCard) dbgCard.style.display = dbgOn ? "" : "none";

    if (dbgOn) {
      $("debugPre").textContent = JSON.stringify({
        stepId: st.stepId,
        form: st.form,
        damage_items_count: st.damage_items.length,
        current_damage_index: st.current_damage_index
      }, null, 2);

      const dd = $("debugDetails");
      if (dd) dd.open = true; // чтобы сразу было видно при включении
    } else {
      $("debugPre").textContent = "";
    }

    if (!st.config) {
      $("stepperCard").style.display = "none";
      setStatus("1) Выбери Config.DB.v5.5.final.json", "muted");
      screen.appendChild(el("div", { class:"row" }, [
        el("div", { text: "Сервис работает офлайн. Сначала выбери файл конфигурации (Config.DB.v5.5.final.json)." })
      ]));
      screen.appendChild(el("div", { class:"muted", style:"margin-top:10px;" , text:
        "Подсказка: файл выбирается через кнопку вверху справа. Сеть не используется."
      }));
      return;
    }

    $("stepperCard").style.display = "";
    const cfg = st.config;
    const steps = cfg.ui.steps;

    // Stepper
    const stepsWrap = $("steps");
    stepsWrap.replaceChildren();
    for (const s of steps) {
      stepsWrap.appendChild(el("button", {
        type:"button",
        class:"stepBtn",
        "aria-current": String(s.id === st.stepId),
        text: s.title,
        onclick: () => {
                // Секрет: 7 тапов по шагу "Анкета" (step1) включает/выключает диагностику
      if (s.id === "step1" && s.title === "Анкета") DebugUnlock.tap();
      
  const stNow = Store.get();
  const stepsNow = stNow.config.ui.steps;

  const curIdx = stepsNow.findIndex(x => x.id === stNow.stepId);
  const tgtIdx = stepsNow.findIndex(x => x.id === s.id);

  // назад (или на текущий) — всегда можно
  if (tgtIdx <= curIdx) {
    Store.update(d => { d.stepId = s.id; });
    refreshStepperAvailability();
    return;
  }

  // вперёд — только на 1 шаг
  if (tgtIdx === curIdx + 1) {
    const ok = (StepGuards.canNextByStepId[stNow.stepId] !== false);
    if (!ok) {
      setStatus("Сначала заполни обязательные поля текущего шага.", "err");
      const damageId = (stNow.stepId === "step3" && stNow.current_damage_index != null) ? stNow.current_damage_index : null;
      UIValidation.markAttempt(stNow.stepId, damageId);
      render();
      return;
    }
    Store.update(d => { d.stepId = s.id; });
    refreshStepperAvailability();
    return;
  }

  // попытка “перепрыгнуть”
  setStatus("Нельзя пропускать шаги. Перейди на следующий шаг по порядку.", "err");
  refreshStepperAvailability();
}
      }));
    }

    // Render current step
    const step = steps.find(x => x.id === st.stepId) || steps[0];
    if (step.id !== st.stepId) {
      // normalize to existing
      Store.update(d => { d.stepId = step.id; }, { skipRender:true });
    }

    if (step.id === "step1") renderStep1(screen, cfg, st);
    else if (step.id === "step2") renderStep2(screen, cfg, st);
    else if (step.id === "step3") renderStep3(screen, cfg, st);
    else if (step.id === "step4") renderStep4(screen, cfg, st);
    else renderUnknownStep(screen, step);
    refreshStepperAvailability();
  }

  function navButtons({ canPrev=true, canNext=true, nextDisabled=false, onPrev, onNext, nextText="Далее" }) {
    const row = el("div", { class:"actions" }, [
      el("button", { type:"button", text:"Назад", disabled: !canPrev, onclick: onPrev }),
      el("button", { type:"button", class:"primary", text: nextText, disabled: !canNext || nextDisabled, onclick: onNext }),
    ]);

    // ВАЖНО: кнопки кладём в sticky footer
    StickyFooter.set(row);

    // А в DOM шага возвращаем невидимую “заглушку”, чтобы шаг не ломался
    return document.createComment("actions-mounted-in-stickyFooter");
  }

  function goNext(cfg, currentId) {
    const steps = cfg.ui.steps;
    const idx = steps.findIndex(s => s.id === currentId);
    if (idx < 0 || idx === steps.length - 1) return;
    const next = steps[idx + 1];
    Store.update(d => { d.stepId = next.id; });
  }
  function goPrev(cfg, currentId) {
    const steps = cfg.ui.steps;
    const idx = steps.findIndex(s => s.id === currentId);
    if (idx <= 0) return;
    const prev = steps[idx - 1];
    Store.update(d => { d.stepId = prev.id; });
  }

  // ===============================
  // Step1 (анкета) — строго по required_fields
  // ===============================
  function renderStep1(root, cfg, st) {
    const fieldsById = indexFieldsById(cfg);
    const step = cfg.ui.steps.find(s => s.id === "step1");
    const required = step?.required_fields || [];

    const _now = new Date();
    // Локальная "сегодня" дата (без сдвига из-за UTC)
    const todayIso = new Date(_now.getTime() - _now.getTimezoneOffset() * 60000).toISOString().slice(0, 10);
    // Автозаполнение: "Дата осмотра" (если поле пустое) = сегодня.
    // Разрешаем пользователю поменять вручную, но стартовое значение ставим автоматически.
    if (required.includes("f_inspection_date") && !String(st.form?.f_inspection_date ?? "").trim()) {
      Store.update(d => {
        if (!String(d.form?.f_inspection_date ?? "").trim()) d.form.f_inspection_date = todayIso;
      }, { skipRender: true });
      st = Store.get();
    }

    root.appendChild(el("div", { text:"Шаг 1: Анкета" , style:"font-weight:800; font-size:16px;" }));
    root.appendChild(el("div", { class:"muted", text:"Заполни обязательные поля." }));

    const fieldUi = new Map(); // fid -> { starEl, errEl }

    // --- local live validation (без полного render на каждый символ) ---
    const step1MissingIds = (form) => {
      const miss = [];
      for (const fid of required) {
        const v = form?.[fid];
        if (!String(v ?? "").trim()) miss.push(fid);
      }
      return miss;
    };

    let nextBtn = null;
    let noteEl = null;

    const refreshStep1Ui = () => {
      const stNow = Store.get();
      const missing = step1MissingIds(stNow.form);

      if (nextBtn) nextBtn.disabled = missing.length > 0;

      if (noteEl) {
        if (missing.length) {
          noteEl.className = "err";
          noteEl.textContent = `Не заполнены обязательные поля: ${missing.join(", ")}`;
        } else {
          noteEl.className = "ok";
          noteEl.textContent = "Все обязательные поля заполнены.";
        }
      }

      // Обновляем debug без перерендера всего экрана
      $("debugPre").textContent = JSON.stringify({
        stepId: stNow.stepId,
        form: stNow.form,
        damage_items_count: stNow.damage_items.length,
        current_damage_index: stNow.current_damage_index
      }, null, 2);
      StepGuards.canNextByStepId.step1 = (missing.length === 0);
      refreshStepperAvailability();

      const attempted = UIValidation.isAttempted("step1");
      const missingSet = new Set(missing);

      // если шаг стал валиден — сбрасываем "attempted", чтобы красные звёзды не висели вечно
      UIValidation.clearAttemptIfValid("step1", null, missing.length === 0);

      for (const fid of required) {
        const ui = fieldUi.get(fid);
        if (!ui) continue;

        const isMissing = missingSet.has(fid);
        const touched = UIValidation.isTouched("step1", fid);

        // показываем текст ошибки: если поле пустое и (его трогали или была попытка перейти дальше)
        const showErrorText = isMissing && (touched || attempted);

        ui.errEl.textContent = showErrorText ? "Заполни обязательное поле." : "";
        ui.errEl.style.display = showErrorText ? "block" : "none";

        // звёздочка красная ТОЛЬКО после попытки перейти дальше
        ui.starEl.classList.toggle("reqStarErr", attempted && isMissing);
      }
    };

    // --- fields ---
    for (const fid of required) {
      const def = fieldsById.get(fid);
      if (!def) {
        root.appendChild(el("div", { class:"err", text:`Config ошибка: поле ${fid} отсутствует в fields[]` }));
        continue;
      }

      const val = st.form?.[fid];

      // Точечные переименования (по запросу) — только отображение на шаге 1.
      // Нормативно лучше менять label в Config.DB, но здесь делаем минимальную правку в UI.
      let labelText = def.label;
      const starEl = el("span", { class: "reqStar", text: "*" });
      const labelEl = el("label", {}, [
        document.createTextNode(labelText),
        document.createTextNode(" "),
        starEl,
      ]);
      root.appendChild(labelEl);

      if (def.type === "text") {
        const input = el("input", { type:"text", value: val ?? "" });
        input.addEventListener("input", () => {
          const v = input.value;
          Store.update(d => { d.form[fid] = v; }, { skipRender: true });
          refreshStep1Ui();
        });
        root.appendChild(input);
        const errEl = el("div", { class: "fieldError", text: "" });
        root.appendChild(errEl);
        fieldUi.set(fid, { starEl, errEl });

        // Валидация onBlur (как в ТЗ), но звёздочку красим только после попытки перейти дальше
        input.addEventListener("blur", () => {
          UIValidation.markTouched("step1", fid);
          refreshStep1Ui();
        });
      }
      else if (def.type === "textarea") {
        const ta = el("textarea", {});
        ta.value = val ?? "";
        ta.addEventListener("input", () => {
          Store.update(d => { d.form[fid] = ta.value; }, { skipRender: true });
          refreshStep1Ui();
        });
        root.appendChild(ta);
        const errEl = el("div", { class: "fieldError", text: "" });
        root.appendChild(errEl);
        fieldUi.set(fid, { starEl, errEl });

        // Валидация onBlur (как в ТЗ), но звёздочку красим только после попытки перейти дальше
        ta.addEventListener("blur", () => {
          UIValidation.markTouched("step1", fid);
          refreshStep1Ui();
        });
      }
      else if (def.type === "date") {
        const input = el("input", { type:"date", value: val ?? "" });

        // Запрет на дату события в будущем
        if (fid === "f_event_date" || fid === "f_policy_date" || fid === "f_inspection_date") {
  input.max = todayIso;
}

        input.addEventListener("change", () => {
          // HTML date input already gives YYYY-MM-DD
          let v = input.value || "";
          if (fid === "f_event_date" && v && v > todayIso) {
            // Жёстко "не даём" поставить будущую дату: возвращаем на сегодня.
            v = todayIso;
            input.value = v;
            alert("Дата события не может быть позже текущей даты.");
          }
          Store.update(d => { d.form[fid] = v; }, { skipRender: true });
          refreshStep1Ui();
        });
        root.appendChild(input);
        const errEl = el("div", { class: "fieldError", text: "" });
        root.appendChild(errEl);
        fieldUi.set(fid, { starEl, errEl });

        // Валидация onBlur (как в ТЗ), но звёздочку красим только после попытки перейти дальше
        input.addEventListener("blur", () => {
          UIValidation.markTouched("step1", fid);
          refreshStep1Ui();
        });
      }
      else {
        // на шаге 1 сейчас не ожидаем других типов
        root.appendChild(el("div", { class:"err", text:`Пока не поддержан type="${def.type}" на step1 (будет в следующей итерации).` }));
      }
    }

    // live note
    noteEl = el("div", { style:"margin-top:10px;" });
    root.appendChild(noteEl);

    // actions (без disabled="false" ловушки)
nextBtn = el("button", {
      type:"button",
      class:"primary",
      text:"Далее",
      onclick: () => goNext(cfg, "step1")
    });
    const row = el("div", { class:"actions" }, [nextBtn]);
    StickyFooter.set(row);
    root.appendChild(document.createComment("actions-mounted-in-stickyFooter"));

    refreshStep1Ui();
  }

  // ===============================
  // Step2 (список повреждений)
  // ===============================
  function renderStep2(root, cfg, st) {
    root.appendChild(el("div", { text:"Шаг 3: Список повреждений" , style:"font-weight:800; font-size:16px;" }));

    const list = el("div", { class:"list" });

    if (!st.damage_items.length) {
      list.appendChild(el("div", { class:"muted", text:"Пока нет повреждений." }));
    } else {
      st.damage_items.forEach((it, idx) => {
        const left = el("div", {}, [
          el("div", { text: `Повреждение ${idx + 1}` , style:"font-weight:700;" }),
        ]);

        const btns = el("div", { class:"row" }, [
          el("button", {
            type:"button",
            text:"Редактировать",
            onclick: () => Store.update(d => { d.current_damage_index = idx; d.stepId = "step3"; })
          }),
          el("button", {
            type:"button",
            text:"Удалить",
            onclick: () => Store.update(d => {
              d.damage_items.splice(idx, 1);
              if (d.current_damage_index === idx) d.current_damage_index = null;
            })
          }),
        ]);

        list.appendChild(el("div", { class:"card item" }, [left, btns]));
      });
    }

    root.appendChild(el("div", { class:"actions" }, [
      el("button", {
        type:"button",
        class:"primary",
        text:"＋ Добавить повреждение",
        onclick: () => Store.update(d => {
          d.damage_items.push({});
          d.current_damage_index = d.damage_items.length - 1;
          d.stepId = "step3";
        })
      }),
    ]));

    root.appendChild(list);

    root.appendChild(navButtons({
      canPrev:true,
      canNext:true,
      nextDisabled:false,
      onPrev: () => goPrev(cfg, "step2"),
      onNext: () => goNext(cfg, "step2"),
      nextText: "Далее → Добавление повреждения"
    }));
  }


  function renderStep3(root, cfg, st) {
  const fieldsById = indexFieldsById(cfg);

  const sel = cfg?.inventory?.damage_item?.selectors;
  if (!sel?.category?.field_id || !sel?.element?.field_id || !sel?.subelement?.field_id) {
    root.appendChild(el("div", { class:"err", text:"Config ошибка: inventory.damage_item.selectors (category/element/subelement.field_id) отсутствует или некорректен." }));
    root.appendChild(navButtons({
      canPrev:true, canNext:true, nextDisabled:false,
      onPrev: () => goPrev(cfg, "step3"),
      onNext: () => goNext(cfg, "step3"),
      nextText: "Далее"
    }));
    return;
  }

  const F_CAT = sel.category.field_id;
  const F_EL  = sel.element.field_id;
  const F_SUB = sel.subelement.field_id;

  const otherKeys = cfg?.state_schema?.damage_item?.value_matching?.other_object_keys || { choice:"choice", other:"other" };
  const K_CHOICE = otherKeys.choice || "choice";
  const K_OTHER  = otherKeys.other || "other";

  const dictById = new Map();
  for (const d of (cfg.dictionaries || [])) dictById.set(d.id, d);

  const getChoice = (v) => {
    if (v && typeof v === "object" && Object.prototype.hasOwnProperty.call(v, K_CHOICE)) return String(v[K_CHOICE] ?? "");
    return String(v ?? "");
  };
  const getOther = (v) => {
    if (v && typeof v === "object" && Object.prototype.hasOwnProperty.call(v, K_OTHER)) return String(v[K_OTHER] ?? "");
    return "";
  };
  const isOtherObj = (v) => v && typeof v === "object" && Object.prototype.hasOwnProperty.call(v, K_CHOICE);

  const buildOrderedValues = (dictId) => {
    const d = dictById.get(dictId);
    if (!d) return [];
    const raw = (d.items || []).map(it => String(it.value ?? ""));
    const ord = d.ordering || { mode:"as_is" };

    let vals = raw.slice();

    const specialsRaw = Array.isArray(ord.special_first_values) ? ord.special_first_values.map(String) : [];
if (specialsRaw.length) {
  const valsSet = new Set(vals);
  const specials = [];
  const seen = new Set();

  for (const v of specialsRaw) {
    if (valsSet.has(v) && !seen.has(v)) {
      specials.push(v);
      seen.add(v);
    }
  }

  if (specials.length) {
    const sset = new Set(specials);
    const rest = vals.filter(v => !sset.has(v));
    vals = [...specials, ...rest];
  }
}
    return vals;
  };

  const matchTemplate = (item) => {
    const cat = getChoice(item?.[F_CAT]);
    const elv = getChoice(item?.[F_EL]);
    const sub = getChoice(item?.[F_SUB]);

    for (const t of (cfg?.inventory?.damage_item?.templates || [])) {
      const w = t?.when || {};

      if (w.category && String(w.category) !== cat) continue;

      // element match
      if (w.element) {
        if (String(w.element) !== elv) continue;
      } else if (Array.isArray(w.element_in)) {
        if (!w.element_in.map(String).includes(elv)) continue;
      }

      // subelement match
      if (w.subelement) {
        if (!sub) continue;
        if (String(w.subelement) !== sub) continue;
      } else if (Array.isArray(w.subelement_in)) {
        if (!sub) continue;
        if (!w.subelement_in.map(String).includes(sub)) continue;
      }

      return t;
    }
    return null;
  };

  const computeElementDictId = (catChoice) => {
    const map = sel?.element?.dictionary_by_category || {};
    return map?.[catChoice] || null;
  };

  const computeSubelementDictId = (catChoice, elChoice) => {
    const map = sel?.subelement?.dictionary_by_category_element || {};
    const key = `${catChoice}|${elChoice}`;
    return map?.[key] || null;
  };

  const idx = st.current_damage_index;
  const item = (idx != null && st.damage_items[idx]) ? st.damage_items[idx] : null;

  root.appendChild(el("div", { text:"Шаг 2: Добавление повреждения", style:"font-weight:800; font-size:16px;" }));


  if (idx == null || !item) {
    root.appendChild(el("div", { class:"err", text:"Сейчас не выбрано повреждение. Вернись на Шаг 2 и нажми “Редактировать” или “＋ Добавить повреждение”." }));
    root.appendChild(navButtons({
      canPrev:true, canNext:true, nextDisabled:false,
      onPrev: () => goPrev(cfg, "step3"),
      onNext: () => goNext(cfg, "step3"),
      nextText: "Далее"
    }));
    return;
  }

  // rules-engine health
  if (!__rulesEngine) {
    root.appendChild(el("div", { class:"err", text:"Rules engine не инициализирован. Проверь, что ты вставил initRulesEngine(cfg) и вызываешь его после загрузки Config.DB и при восстановлении из IDB." }));
  } else if (Array.isArray(__rulesErrors) && __rulesErrors.length) {
    root.appendChild(el("div", { class:"err", text:"Rules engine: найдены ошибки/предупреждения в правилах: " + __rulesErrors.join("; ") }));
  }

  // ---------- helpers for updates ----------
  const refreshDebugOnly = () => {
    const stNow = Store.get();
    $("debugPre").textContent = JSON.stringify({
      stepId: stNow.stepId,
      form: stNow.form,
      damage_items_count: stNow.damage_items.length,
      current_damage_index: stNow.current_damage_index
    }, null, 2);
  };

  const applyRulesCommit = (prevItemSnap, nextItemDraft, draftState) => {
    if (!__rulesEngine) return;
    try {
      const out = __rulesEngine.applyRules({ prevItem: prevItemSnap, nextItem: nextItemDraft });
      draftState.damage_items[idx] = out.nextItem;
    } catch (e) {
      console.error("Rules apply failed:", e);
    }
  };

  const clearToSelectorsAndPhotos = (it) => {
    const keep = new Set([F_CAT, F_EL, F_SUB, "f_photos"]);
    for (const k of Object.keys(it || {})) {
      if (!keep.has(k)) delete it[k];
    }
  };

  // ---------- selectors current values ----------
  const catChoice = getChoice(item[F_CAT]);
  const elChoice  = getChoice(item[F_EL]);
  const subChoice = getChoice(item[F_SUB]);

  const catDictId = sel.category.dictionary_id;
const elDictId  = catChoice ? computeElementDictId(catChoice) : null;

// Элемент показываем только там, где Config.DB дал словарь для выбранной категории
const showElement = !!elDictId;

const subDictId = (catChoice && showElement && elChoice)
  ? computeSubelementDictId(catChoice, elChoice)
  : null;

const showSubelement = !!subDictId; // как и было: только если есть словарь по category|element

  // runtime (for visibility/required/dictionary overrides)
  let runtime = { fields:{} };
  try {
    if (__rulesEngine) {
      const out = __rulesEngine.applyRules({ prevItem: item, nextItem: item });
      runtime = out.runtime || runtime;
    }
  } catch (e) {
    console.error(e);
  }
  const rtFor = (fid) => (runtime?.fields?.[fid] || {});
  const isVisible = (fid) => (rtFor(fid).visible === false) ? false : true;

  // ---------- UI: selectors card ----------
  const selectorsCard = el("div", { class:"card", style:"padding:12px; margin-top:10px;" });
  const fieldUi = new Map(); // fid -> { starEl, errEl }

  const renderSelectWithOther = ({ fid, label, required, dictId, disabled, allowOther }) => {
    const def = fieldsById.get(fid) || { id: fid, label, type:"select" };
    const otherChoiceValue = String(def.other_choice_value || "Иное");

    const starEl = el("span", { class: "reqStar", text: "*" });
    // тут required для селекторов всегда true, потому что они участвуют в requiredSelectors в computeMissing
    selectorsCard.appendChild(el("label", {}, [
      document.createTextNode(label),
      document.createTextNode(" "),
      starEl,
    ]));

    const opts = dictId ? buildOrderedValues(dictId) : [];
    const select = el("select", { disabled: !!disabled });

    // empty
    select.appendChild(el("option", { value:"", text:"— выбери —" }));

    // options from dictionary
    for (const v of opts) select.appendChild(el("option", { value:v, text:v }));

    // if allowOther but dictionary doesn't contain "Иное" — добавим
    if (allowOther && !opts.includes(otherChoiceValue)) {
      select.appendChild(el("option", { value: otherChoiceValue, text: otherChoiceValue }));
    }

    const curVal = Store.get().damage_items[idx]?.[fid];
    select.value = getChoice(curVal) || "";

    // other input (if needed)
    let otherInput = null;
    const maybeRenderOther = () => {
      const stNow = Store.get();
      const vNow = stNow.damage_items[idx]?.[fid];
      const choiceNow = getChoice(vNow);
      const needsOther = allowOther && choiceNow === otherChoiceValue;
      if (!needsOther) {
        if (otherInput) { otherInput.remove(); otherInput = null; }
        return;
      }
      if (!otherInput) {
        otherInput = el("input", { type:"text", value: getOther(vNow) || "", placeholder:"Укажи своё значение (Иное)" });
        otherInput.addEventListener("input", () => {
          const valText = otherInput.value;
          Store.update(d => {
            const it = d.damage_items[idx];
            if (!it) return;
            const base = it[fid];
            const obj = (base && typeof base === "object") ? base : {};
            it[fid] = { [K_CHOICE]: otherChoiceValue, [K_OTHER]: valText };
          }, { skipRender:true });
          refreshDebugOnly();
          refreshStep3Ui();
        });
        otherInput.addEventListener("blur", () => {
          UIValidation.markTouched("step3", fid, idx);
          refreshStep3Ui();
        });
        selectorsCard.appendChild(otherInput);
      } else {
        otherInput.value = getOther(vNow) || "";
      }
    };

    select.addEventListener("change", () => {
      UIValidation.markTouched("step3", fid, idx);
      const v = select.value || "";

      const st0 = Store.get();
      const prevSnap = safeClone(st0.damage_items[idx] || {});

      Store.update(d => {
        const it = d.damage_items[idx];
        if (!it) return;

        // on any selector change: чистим все поля (кроме selectors+photos) чтобы не таскать мусор между шаблонами
        // + дочерние селекторы сбрасываем при смене родителя
        if (fid === F_CAT) {
          if (v) it[F_CAT] = v; else delete it[F_CAT];
          delete it[F_EL];
          delete it[F_SUB];
          clearToSelectorsAndPhotos(it);
        } else if (fid === F_EL) {
          if (!v) delete it[F_EL];
          else if (allowOther && v === otherChoiceValue) it[F_EL] = { [K_CHOICE]: otherChoiceValue, [K_OTHER]: getOther(it[F_EL]) || "" };
          else it[F_EL] = v;

          delete it[F_SUB];
          clearToSelectorsAndPhotos(it);
        } else if (fid === F_SUB) {
          if (!v) delete it[F_SUB];
          else if (allowOther && v === otherChoiceValue) it[F_SUB] = { [K_CHOICE]: otherChoiceValue, [K_OTHER]: getOther(it[F_SUB]) || "" };
          else it[F_SUB] = v;

          clearToSelectorsAndPhotos(it);
        } else {
          // generic
          if (!v) delete it[fid];
          else it[fid] = v;
        }

        // apply rules after selector change
        applyRulesCommit(prevSnap, it, d);
      });

      // re-render to show correct template/fields
    });

    select.addEventListener("blur", () => {
      UIValidation.markTouched("step3", fid, idx);
      refreshStep3Ui();
    });

    selectorsCard.appendChild(select);
    const errEl = el("div", { class: "fieldError", text: "" });
    selectorsCard.appendChild(errEl);
    fieldUi.set(fid, { starEl, errEl });
    maybeRenderOther();
  };

// Category tiles (4 крупных значка)
{
  const catLabel = (fieldsById.get(F_CAT)?.label || "Категория");
  const starEl = el("span", { class:"reqStar", text:"*" });

  selectorsCard.appendChild(el("label", {}, [
    document.createTextNode(catLabel),
    document.createTextNode(" "),
    starEl
  ]));

  const tiles = el("div", { class:"catTiles" });
  const iconByCat = {
    "Помещение":"🏠",
    "Здание":"🏢",
    "Мебель":"🛋️",
    "Остекление":"🪟"
  };

  for (const v of buildOrderedValues(catDictId)) {
    if (!iconByCat[v]) continue; // строго 4 категории
    const isActive = (catChoice === v);

    tiles.appendChild(el("button", {
      type:"button",
      class: "catTile" + (isActive ? " active" : ""),
      onclick: () => {
        if (catChoice === v) return;

        UIValidation.markTouched("step3", F_CAT, idx);

        const st0 = Store.get();
        const prevSnap = safeClone(st0.damage_items[idx] || {});

        Store.update(d => {
          const it = d.damage_items[idx];
          if (!it) return;

          it[F_CAT] = v;
          delete it[F_EL];
          delete it[F_SUB];

          // очистка полей шаблона при смене категории (как и было в dropdown)
          clearToSelectorsAndPhotos(it);

          applyRulesCommit(prevSnap, it, d);
        });
      }
    }, [
      el("div", { class:"catTileIcon", text: iconByCat[v] }),
      el("div", { class:"catTileLabel", text: v })
    ]));
  }

  selectorsCard.appendChild(tiles);

  const errEl = el("div", { class:"fieldError", text:"" });
  selectorsCard.appendChild(errEl);

  // важно: чтобы валидация (звёздочка/ошибка) работала как раньше
  fieldUi.set(F_CAT, { starEl, errEl });
}

// Element (только если применим для выбранной категории)
if (showElement) {
  renderSelectWithOther({
    fid: F_EL,
    label: (fieldsById.get(F_EL)?.label || "Элемент"),
    required: true,
    dictId: elDictId,
    disabled: !catChoice || !elDictId,
    allowOther: true
  });
} else {
  // если элемент не применим (например категория "Мебель") — чистим ключи на всякий случай
  if (Object.prototype.hasOwnProperty.call(item, F_EL) || Object.prototype.hasOwnProperty.call(item, F_SUB)) {
    const st0 = Store.get();
    const prevSnap = safeClone(st0.damage_items[idx] || {});
    Store.update(d => {
      const it = d.damage_items[idx];
      if (!it) return;
      delete it[F_EL];
      delete it[F_SUB];
      applyRulesCommit(prevSnap, it, d);
    });
  }
}

  // Subelement (только если есть dictionary_by_category_element)
  if (showSubelement) {
    renderSelectWithOther({
      fid: F_SUB,
      label: (fieldsById.get(F_SUB)?.label || "Подэлемент"),
      required: false, // реальная required будет по шаблону ниже
      dictId: subDictId,
      disabled: !catChoice || !elChoice || !subDictId,
      allowOther: true
    });
  } else {
    // если subelement не применим — чистим его на всякий случай
    if (Object.prototype.hasOwnProperty.call(item, F_SUB)) {
      const st0 = Store.get();
      const prevSnap = safeClone(st0.damage_items[idx] || {});
      Store.update(d => {
        const it = d.damage_items[idx];
        if (!it) return;
        delete it[F_SUB];
        applyRulesCommit(prevSnap, it, d);
      });
    }
  }

  root.appendChild(selectorsCard);

  // ---------- template ----------
  const tmpl = matchTemplate(Store.get().damage_items[idx] || {});
  if (!tmpl) {
    const stNow = Store.get();
    const itNow = stNow.damage_items[idx] || {};
    const c = getChoice(itNow[F_CAT]);
    const e = getChoice(itNow[F_EL]);
    const s = getChoice(itNow[F_SUB]);

    let msg = "Выбери Категорию.";
if (c && showElement && !e) msg = "Выбери Элемент.";
if (c && showElement && e && showSubelement && !s) msg = "Выбери Подэлемент.";
if (c && (!showElement || e) && (!showSubelement || s)) {
  msg = "Под текущие значения не найден шаблон (template). Проверь Config.DB.templates.";
}

    root.appendChild(el("div", { class:"muted", style:"margin-top:10px;", text: msg }));

    // nav
    root.appendChild(navButtons({
      canPrev:true,
      canNext:true,
      nextDisabled:true,
      onPrev: () => goPrev(cfg, "step3"),
      onNext: () => goNext(cfg, "step3"),
      nextText: "Далее"
    }));
    return;
  }

  // template field lookup
  const tmplFieldById = new Map();
  for (const f of (tmpl.fields || [])) tmplFieldById.set(f.field_id, f);

  const getFinalDictId = (fid) => {
    const rt = rtFor(fid);
    if (Object.prototype.hasOwnProperty.call(rt, "dictionary_id")) return rt.dictionary_id; // может быть null
    const tf = tmplFieldById.get(fid);
    if (tf?.dictionary_id) return tf.dictionary_id;
    const def = fieldsById.get(fid);
    return def?.dictionary_id || null;
  };

  const getFinalRequired = (fid) => {
    const rt = rtFor(fid);
    if (typeof rt.required === "boolean") return rt.required;
    const tf = tmplFieldById.get(fid);
    if (typeof tf?.required === "boolean") return tf.required;
    const def = fieldsById.get(fid);
    return !!def?.required;
  };

  const isFilled = (fid, v, def) => {
    if (!isVisible(fid)) return true; // скрытое не требуем

    if (def?.type === "group_xy") {
      const o = (v && typeof v === "object") ? v : {};
      const xOk = typeof o.x === "number" && !Number.isNaN(o.x);
      const yOk = typeof o.y === "number" && !Number.isNaN(o.y);
      return xOk && yOk;
    }
    if (def?.type === "group_xyz") {
      const o = (v && typeof v === "object") ? v : {};
      const xOk = typeof o.x === "number" && !Number.isNaN(o.x);
      const yOk = typeof o.y === "number" && !Number.isNaN(o.y);
      const zOk = typeof o.z === "number" && !Number.isNaN(o.z);
      return xOk && yOk && zOk;
    }
    if (def?.type === "select") {
      const choice = getChoice(v);
      if (!choice) return false;
      if (def.allow_other_choice && choice === String(def.other_choice_value || "Иное")) {
        return !!getOther(v).trim();
      }
      return true;
    }
    if (fid === "f_photos") {
      const arr = Array.isArray(v) ? v : [];
      return arr.length > 0;
    }
    if (def?.type === "number") {
      return typeof v === "number" && !Number.isNaN(v);
    }
    // text/textarea/date
    return !!String(v ?? "").trim();
  };

  // ---------- missing + live UI (без полного render на каждый символ) ----------
  let noteEl = null;
  let nextBtn = null;

  const computeMissing = () => {
    const stNow = Store.get();
    const itNow = stNow.damage_items[idx] || {};
    const miss = [];

    // selectors
const c = getChoice(itNow[F_CAT]);
const e = getChoice(itNow[F_EL]);
if (!c) miss.push(F_CAT);
if (showElement && !e) miss.push(F_EL);

    if (showSubelement) {
      const tfSub = tmplFieldById.get(F_SUB);
      const subReq = (typeof tfSub?.required === "boolean") ? tfSub.required : false;
      if (subReq) {
        const s = getChoice(itNow[F_SUB]);
        if (!s) miss.push(F_SUB);
        else if (fieldsById.get(F_SUB)?.allow_other_choice && s === String(fieldsById.get(F_SUB).other_choice_value || "Иное")) {
          if (!getOther(itNow[F_SUB]).trim()) miss.push(F_SUB);
        }
      }
    }

    // template fields (skip selectors we already handle)
    for (const tf of (tmpl.fields || [])) {
      const fid = tf.field_id;
      if (fid === F_CAT || fid === F_EL) continue;
      if (fid === F_SUB && showSubelement) continue; // subelement уже в selectors UI
      if (!isVisible(fid)) continue;

      const def = fieldsById.get(fid);
      if (!def) continue;

      const req = getFinalRequired(fid);
      if (!req) continue;

      const v = itNow[fid];
      if (!isFilled(fid, v, def)) miss.push(fid);
    }

    return miss;
  };

  const refreshStep3Ui = () => {
    const missing = computeMissing();

    if (nextBtn) nextBtn.disabled = missing.length > 0;

    if (noteEl) {
      if (missing.length) {
        const labels = missing.map(fid => fieldsById.get(fid)?.label || fid);
        noteEl.className = "err";
        noteEl.textContent = "Не заполнены обязательные поля: " + labels.join(", ");
      } else {
        noteEl.className = "ok";
        noteEl.textContent = "Все обязательные поля заполнены.";
      }
    }
    StepGuards.canNextByStepId.step3 = (missing.length === 0);
    refreshStepperAvailability();

    refreshDebugOnly();

    const stNow = Store.get();
    const attempted = UIValidation.isAttempted("step3", idx);
    const missingSet = new Set(missing);

    // если стало валидно — сброс attempted для этого damage_item
    UIValidation.clearAttemptIfValid("step3", idx, missing.length === 0);

    // сообщение для фото берём из constraints (как в ТЗ)
    const minPhotos =
      (cfg?.constraints?.photos?.min_per_damage_item ?? 1);

    for (const [fid, ui] of fieldUi.entries()) {
      const isMissing = missingSet.has(fid);
      const touched = UIValidation.isTouched("step3", fid, idx);

      const showErrorText = isMissing && (touched || attempted);

      let msg = "Заполни обязательное поле.";
      if (fid === "f_photos") msg = `Добавь минимум ${minPhotos} фото.`;
      ui.errEl.textContent = showErrorText ? msg : "";
      ui.errEl.style.display = showErrorText ? "block" : "none";

      // звёздочка красная только после попытки перейти дальше
      ui.starEl?.classList.toggle("reqStarErr", attempted && isMissing);
    }
  };

  // ---------- render template fields ----------
  const fieldsCard = el("div", { class:"card", style:"padding:12px; margin-top:10px;" });

  const setValueNoRender = (fid, val) => {
    Store.update(d => {
      const it = d.damage_items[idx];
      if (!it) return;
      if (val === undefined || val === null || (typeof val === "string" && !val.trim())) {
        delete it[fid];
      } else {
        it[fid] = val;
      }
    }, { skipRender:true });
    refreshStep3Ui();
  };

  const commitValueWithRules = (mutatorFn) => {
    const st0 = Store.get();
    const prevSnap = safeClone(st0.damage_items[idx] || {});
    Store.update(d => {
      const it = d.damage_items[idx];
      if (!it) return;
      mutatorFn(it);
      applyRulesCommit(prevSnap, it, d);
    });
  };

  const renderTextField = (fid, def, required) => {
    const starEl = el("span", { class: "reqStar", text: "*" });
    const labelEl = required
      ? el("label", {}, [document.createTextNode(def.label), document.createTextNode(" "), starEl])
      : el("label", { text: def.label });
    fieldsCard.appendChild(labelEl);
    const inp = el("input", { type:"text", value: (Store.get().damage_items[idx]?.[fid] ?? "") });
    inp.addEventListener("input", () => setValueNoRender(fid, inp.value));
    inp.addEventListener("change", () => {
      commitValueWithRules(it => {
        const v = inp.value || "";
        if (!v.trim()) delete it[fid];
        else it[fid] = v;
      });
    });
    fieldsCard.appendChild(inp);
    const errEl = el("div", { class: "fieldError", text: "" });
    fieldsCard.appendChild(errEl);
    if (required) fieldUi.set(fid, { starEl, errEl });
    inp.addEventListener("blur", () => {
      UIValidation.markTouched("step3", fid, idx);
      refreshStep3Ui();
    }, true);
  };

  const renderTextareaField = (fid, def, required) => {
    const starEl = el("span", { class: "reqStar", text: "*" });
    const labelEl = required
      ? el("label", {}, [document.createTextNode(def.label), document.createTextNode(" "), starEl])
      : el("label", { text: def.label });
    fieldsCard.appendChild(labelEl);
    const ta = el("textarea", {});
    ta.value = (Store.get().damage_items[idx]?.[fid] ?? "");
    ta.addEventListener("input", () => setValueNoRender(fid, ta.value));
    ta.addEventListener("change", () => {
      commitValueWithRules(it => {
        const v = ta.value || "";
        if (!v.trim()) delete it[fid];
        else it[fid] = v;
      });
    });
    fieldsCard.appendChild(ta);
    const errEl = el("div", { class: "fieldError", text: "" });
    fieldsCard.appendChild(errEl);
    if (required) fieldUi.set(fid, { starEl, errEl });
    ta.addEventListener("blur", () => {
      UIValidation.markTouched("step3", fid, idx);
      refreshStep3Ui();
    }, true);
  };

  const renderDateField = (fid, def, required) => {
    const starEl = el("span", { class: "reqStar", text: "*" });
    const labelEl = required
      ? el("label", {}, [document.createTextNode(def.label), document.createTextNode(" "), starEl])
      : el("label", { text: def.label });
    fieldsCard.appendChild(labelEl);
    const inp = el("input", { type:"date", value: (Store.get().damage_items[idx]?.[fid] ?? "") });
    inp.addEventListener("change", () => {
      const v = inp.value || "";
      commitValueWithRules(it => {
        if (!v) delete it[fid];
        else it[fid] = v; // YYYY-MM-DD
      });
    });
    fieldsCard.appendChild(inp);
    const errEl = el("div", { class: "fieldError", text: "" });
    fieldsCard.appendChild(errEl);
    if (required) fieldUi.set(fid, { starEl, errEl });
    inp.addEventListener("blur", () => {
      UIValidation.markTouched("step3", fid, idx);
      refreshStep3Ui();
    }, true);
  };

  const renderNumberField = (fid, def, required) => {
    const starEl = el("span", { class: "reqStar", text: "*" });
    const labelEl = required
      ? el("label", {}, [document.createTextNode(def.label), document.createTextNode(" "), starEl])
      : el("label", { text: def.label });
    fieldsCard.appendChild(labelEl);
    const cur = Store.get().damage_items[idx]?.[fid];
    const inp = el("input", { type:"number", value: (typeof cur === "number" ? String(cur) : "") });
    inp.addEventListener("input", () => {
      const s = inp.value;
      if (!s.trim()) { setValueNoRender(fid, undefined); return; }
      const n = Number(s);
      if (Number.isFinite(n)) setValueNoRender(fid, n);
      else setValueNoRender(fid, undefined);
    });
    inp.addEventListener("change", () => {
      const s = inp.value;
      commitValueWithRules(it => {
        if (!s.trim()) { delete it[fid]; return; }
        const n = Number(s);
        if (!Number.isFinite(n)) { delete it[fid]; return; }
        it[fid] = n;
      });
    });
    fieldsCard.appendChild(inp);
    const errEl = el("div", { class: "fieldError", text: "" });
    fieldsCard.appendChild(errEl);
    if (required) fieldUi.set(fid, { starEl, errEl });
    inp.addEventListener("blur", () => {
      UIValidation.markTouched("step3", fid, idx);
      refreshStep3Ui();
    }, true);
  };

  const renderSelectField = (fid, def, required, dictId) => {
    const otherChoiceValue = String(def.other_choice_value || "Иное");
    const starEl = el("span", { class: "reqStar", text: "*" });
    const labelEl = required
      ? el("label", {}, [document.createTextNode(def.label), document.createTextNode(" "), starEl])
      : el("label", { text: def.label });
    fieldsCard.appendChild(labelEl);

    const select = el("select", { disabled: !dictId });
    select.appendChild(el("option", { value:"", text:"— выбери —" }));

    const opts = dictId ? buildOrderedValues(dictId) : [];
    for (const v of opts) select.appendChild(el("option", { value:v, text:v }));

    if (def.allow_other_choice && !opts.includes(otherChoiceValue)) {
      select.appendChild(el("option", { value: otherChoiceValue, text: otherChoiceValue }));
    }

    const curVal = Store.get().damage_items[idx]?.[fid];
    select.value = getChoice(curVal) || "";

    let otherInput = null;

    const ensureOther = () => {
      const stNow = Store.get();
      const vNow = stNow.damage_items[idx]?.[fid];
      const choiceNow = getChoice(vNow);
      const needs = def.allow_other_choice && choiceNow === otherChoiceValue;

      if (!needs) {
        if (otherInput) { otherInput.remove(); otherInput = null; }
        return;
      }

      if (!otherInput) {
        otherInput = el("input", { type:"text", value: getOther(vNow) || "", placeholder:"Укажи своё значение (Иное)" });
        otherInput.addEventListener("input", () => {
          const textV = otherInput.value;
          Store.update(d => {
            const it = d.damage_items[idx];
            if (!it) return;
            it[fid] = { [K_CHOICE]: otherChoiceValue, [K_OTHER]: textV };
          }, { skipRender:true });
          refreshStep3Ui();
        });
        otherInput.addEventListener("blur", () => {
          UIValidation.markTouched("step3", fid, idx);
          refreshStep3Ui();
        });
        fieldsCard.appendChild(otherInput);
      } else {
        otherInput.value = getOther(vNow) || "";
      }
    };

    select.addEventListener("change", () => {
      UIValidation.markTouched("step3", fid, idx);
      const v = select.value || "";
      commitValueWithRules(it => {
        if (!v) { delete it[fid]; return; }
        if (def.allow_other_choice && v === otherChoiceValue) {
          const prevOther = isOtherObj(it[fid]) ? getOther(it[fid]) : "";
          it[fid] = { [K_CHOICE]: otherChoiceValue, [K_OTHER]: prevOther };
        } else {
          it[fid] = v;
        }
      });
    });

    select.addEventListener("blur", () => {
      UIValidation.markTouched("step3", fid, idx);
      refreshStep3Ui();
    });

    fieldsCard.appendChild(select);
    const errEl = el("div", { class: "fieldError", text: "" });
    fieldsCard.appendChild(errEl);
    if (required) fieldUi.set(fid, { starEl, errEl });
    ensureOther();
  };

  const renderGroupField = (fid, def, required) => {
    const starEl = el("span", { class: "reqStar", text: "*" });
    const labelEl = required
      ? el("label", {}, [document.createTextNode(def.label), document.createTextNode(" "), starEl])
      : el("label", { text: def.label });
    fieldsCard.appendChild(labelEl);

    const cur = Store.get().damage_items[idx]?.[fid];
    const obj = (cur && typeof cur === "object") ? cur : {};

    const row = el("div", { class:"row", style:"gap:10px; align-items:flex-end; flex-wrap:wrap;" });

    const makeAxis = (axisKey, axisLabel) => {
      const wrap = el("div", {}, [
        el("div", { class:"muted", text: axisLabel || axisKey })
      ]);
      const inp = el("input", { type:"number", value: (typeof obj[axisKey] === "number" ? String(obj[axisKey]) : "") });
      inp.addEventListener("input", () => {
        const s = inp.value;
        Store.update(d => {
          const it = d.damage_items[idx];
          if (!it) return;
          const curV = it[fid];
          const o = (curV && typeof curV === "object") ? curV : {};
          if (!s.trim()) {
            delete o[axisKey];
          } else {
            const n = Number(s);
            if (Number.isFinite(n)) o[axisKey] = n;
            else delete o[axisKey];
          }
          // если пусто — удаляем поле целиком
          const hasAny = ["x","y","z"].some(k => typeof o[k] === "number" && Number.isFinite(o[k]));
          if (!hasAny && !o.unit) delete it[fid];
          else it[fid] = o;
        }, { skipRender:true });
        refreshStep3Ui();
      });
      inp.addEventListener("change", () => {
        commitValueWithRules(it => {
          const curV = it[fid];
          const o = (curV && typeof curV === "object") ? curV : {};
          const s = inp.value;
          if (!s.trim()) delete o[axisKey];
          else {
            const n = Number(s);
            if (Number.isFinite(n)) o[axisKey] = n;
            else delete o[axisKey];
          }
          const hasAny = ["x","y","z"].some(k => typeof o[k] === "number" && Number.isFinite(o[k]));
          if (!hasAny && !o.unit) delete it[fid];
          else it[fid] = o;
        });
      });
      inp.addEventListener("blur", () => {
        UIValidation.markTouched("step3", fid, idx);
        refreshStep3Ui();
      }, true);
      wrap.appendChild(inp);
      return wrap;
    };

    const labels = def.axis_labels || {};
    row.appendChild(makeAxis("x", labels.x));
    row.appendChild(makeAxis("y", labels.y));
    if (def.type === "group_xyz") row.appendChild(makeAxis("z", labels.z));

    // unit
    if (def.unit_static) {
      row.appendChild(el("div", { class:"muted", text:`Ед.: ${def.unit_static}` }));
      // записываем unit_static в state при первом рендере, если уже есть объект
      if (Store.get().damage_items[idx]?.[fid] && typeof Store.get().damage_items[idx][fid] === "object") {
        const cur2 = Store.get().damage_items[idx][fid];
        if (!cur2.unit) {
          Store.update(d => {
            const it = d.damage_items[idx];
            if (!it) return;
            const o = (it[fid] && typeof it[fid] === "object") ? it[fid] : {};
            o.unit = String(def.unit_static);
            it[fid] = o;
          }, { skipRender:true });
        }
      }
    } else if (def.unit_options_dictionary_id) {
      const uWrap = el("div", {}, [ el("div", { class:"muted", text:"Ед." }) ]);
      const uSel = el("select", {});
      uSel.appendChild(el("option", { value:"", text:"—" }));
      for (const u of buildOrderedValues(def.unit_options_dictionary_id)) {
        uSel.appendChild(el("option", { value:u, text:u }));
      }
      uSel.value = String(obj.unit ?? "");
      uSel.addEventListener("change", () => {
        const u = uSel.value || "";
        Store.update(d => {
          const it = d.damage_items[idx];
          if (!it) return;
          const curV = it[fid];
          const o = (curV && typeof curV === "object") ? curV : {};
          if (!u) delete o.unit;
          else o.unit = u;
          const hasAny = ["x","y","z"].some(k => typeof o[k] === "number" && Number.isFinite(o[k]));
          if (!hasAny && !o.unit) delete it[fid];
          else it[fid] = o;
        }, { skipRender:true });
        refreshStep3Ui();
      });
      uWrap.appendChild(uSel);
      row.appendChild(uWrap);
    }

    fieldsCard.appendChild(row);
    const errEl = el("div", { class: "fieldError", text: "" });
    fieldsCard.appendChild(errEl);
    if (required) fieldUi.set(fid, { starEl, errEl });
  };

  const renderPhotosField = (fid, def, required) => {
    const starEl = el("span", { class: "reqStar", text: "*" });
    const labelEl = required
      ? el("label", {}, [document.createTextNode(def.label), document.createTextNode(" "), starEl])
      : el("label", { text: def.label });
    fieldsCard.appendChild(labelEl);

    const stNow = Store.get();
    const itNow = stNow.damage_items[idx] || {};
    const cur = Array.isArray(itNow[fid]) ? itNow[fid] : [];

    const max = Math.min(
      cfg?.constraints?.photos?.max_per_damage_item ?? 10,
      def.max_count ?? 10
    );

    const info = el("div", { class:"muted", style:"margin-top:6px;", text:`Максимум ${max} фото на повреждение. Загружено: ${cur.length}/${max} фото.` });
    fieldsCard.appendChild(info);

    const msg = el("div", { class:"muted", style:"margin-top:6px;" });
    fieldsCard.appendChild(msg);

    const input = el("input", {
  type:"file",
  accept:"image/*",
  multiple:true,
  style:"display:none;"
});

    fieldsCard.appendChild(input);

    const btn = el("button", { type:"button", class:"primary", text:"Добавить фото", style:"margin-top:10px;" });
    btn.disabled = (cur.length >= max);
    fieldsCard.appendChild(btn);

    const grid = el("div", { class:"thumbGrid" });
    fieldsCard.appendChild(grid);

    const rebuildGrid = async () => {
      const st2 = Store.get();
      const it2 = st2.damage_items[idx] || {};
      const arr = Array.isArray(it2[fid]) ? it2[fid] : [];
      grid.replaceChildren();

      for (const photoId of arr) {
        const card = el("div", { class:"thumbCard" });
        const img = el("img", { class:"thumbImg" });
        card.appendChild(img);

        ImagePipeline.getThumbUrl(photoId).then(url => { if (url) img.src = url; });

        const meta = el("div", { class:"thumbMeta" });
        meta.appendChild(el("span", { text: photoId.slice(0,8) + "…" }));

        const del = el("button", { type:"button", class:"thumbBtn", text:"Удалить" });
        del.addEventListener("click", async () => {
          if (!confirm("Удалить это фото?")) return;

          Store.update(d => {
            const it3 = d.damage_items[idx];
            if (!it3) return;
            const a = Array.isArray(it3[fid]) ? it3[fid] : [];
            it3[fid] = a.filter(x => x !== photoId);
          });

          try { await Persistence.deleteImageRecord(photoId); } catch (e) { console.error(e); }
          ImagePipeline.revoke(photoId);
        });

        meta.appendChild(del);
        card.appendChild(meta);
        grid.appendChild(card);
      }

      const st3 = Store.get();
      const it3 = st3.damage_items[idx] || {};
      const a3 = Array.isArray(it3[fid]) ? it3[fid] : [];
      info.textContent = `Максимум ${max} фото на повреждение. Добавлено: ${a3.length}/${max} фото.`;
      btn.disabled = (a3.length >= max);
    };
    input.addEventListener("change", async () => {
  const files = Array.from(input.files || []);
  if (!files.length) return;

  const st2 = Store.get();
  const it2 = st2.damage_items[idx] || {};
  const arr = Array.isArray(it2[fid]) ? it2[fid] : [];
  const remaining = Math.max(0, max - arr.length);
  if (remaining <= 0) {
    input.value = "";
    return;
  }

  const toAdd = files.slice(0, remaining);

  btn.disabled = true;
  input.disabled = true;
  msg.textContent = `Обработка фото: 0 / ${toAdd.length}`;

  try {
    await ImagePipeline.init(cfg);
    const newIds = await ImagePipeline.processAndStoreFiles({
      cfg,
      files: toAdd,
      onProgress: (done, total) => { msg.textContent = `Обработка фото: ${done} / ${total}`; }
    });

    Store.update(d => {
      const it3 = d.damage_items[idx];
      if (!it3) return;
      const a = Array.isArray(it3[fid]) ? it3[fid] : [];
      it3[fid] = [...a, ...newIds];
    });

    msg.textContent = "Готово.";
  } catch (e) {
    console.error(e);
    alert(formatErr(e));
    msg.textContent = "Ошибка (см. консоль).";
  } finally {
    input.disabled = false;
    input.value = "";
    await rebuildGrid();
  }
});

btn.addEventListener("click", () => {
  if (btn.disabled) return;

  UIValidation.markTouched("step3", "f_photos", idx);

  const st2 = Store.get();
  const it2 = st2.damage_items[idx] || {};
  const arr = Array.isArray(it2[fid]) ? it2[fid] : [];
  const remaining = Math.max(0, max - arr.length);

  alert(
    "Сделай/загрузи фото в горизонтальной ориентации. Один ракурс — одно фото. " +
    `Лимит: максимум ${max} фото на повреждение (осталось ${remaining}).`
  );

  input.click();
});

    const errEl = el("div", { class: "fieldError", text: "" });
    fieldsCard.appendChild(errEl);
    if (required) fieldUi.set(fid, { starEl, errEl });

    // initial render
    rebuildGrid();
  };

  for (const tf of (tmpl.fields || [])) {
    const fid = tf.field_id;

    // не рендерим selectors повторно
    if (fid === F_CAT || fid === F_EL) continue;
    if (fid === F_SUB && showSubelement) continue;

    const def = fieldsById.get(fid);
    if (!def) {
      fieldsCard.appendChild(el("div", { class:"err", text:`Config ошибка: поле "${fid}" отсутствует в cfg.fields[]` }));
      continue;
    }

    if (!isVisible(fid)) {
      // если скрыто — показывать не надо
      continue;
    }

    const required = getFinalRequired(fid);
    const dictId = (def.type === "select") ? getFinalDictId(fid) : null;

    if (def.type === "text") renderTextField(fid, def, required);
    else if (def.type === "textarea") renderTextareaField(fid, def, required);
    else if (def.type === "date") renderDateField(fid, def, required);
    else if (def.type === "number") renderNumberField(fid, def, required);
    else if (def.type === "select") renderSelectField(fid, def, required, dictId);
    else if (def.type === "group_xy" || def.type === "group_xyz") renderGroupField(fid, def, required);
    else if (fid === "f_photos") renderPhotosField(fid, def, required);
    else {
      fieldsCard.appendChild(el("div", { class:"err", text:`Пока не поддержан type="${def.type}" для поля ${fid} на Step3.` }));
    }
  }

  root.appendChild(fieldsCard);

  // note (required missing)
  noteEl = el("div", { style:"margin-top:10px;" });
  root.appendChild(noteEl);

  // actions: добавить новое повреждение, не уходя на Step2
  const addMoreRow = el("div", { class:"actions" }, [
    el("button", {
      type:"button",
      class:"primary",
      text:"＋ Добавить новое повреждение",
      onclick: () => Store.update(d => {
        d.damage_items.push({});
        d.current_damage_index = d.damage_items.length - 1;
        d.stepId = "step3";
      })
    }),
  ]);
  root.appendChild(addMoreRow);

  // nav buttons (next disabled when required missing)
  const nav = navButtons({
    canPrev:true,
    canNext:true,
    nextDisabled: true, // обновим ниже
    onPrev: () => goPrev(cfg, "step3"),
    onNext: () => goNext(cfg, "step3"),
    nextText: "Далее"
  });

  // получить ссылку на next button (кнопки в StickyFooter, nav — это comment-заглушка)
  nextBtn = document.querySelector("#stickyFooterInner button.primary");
  root.appendChild(nav);

  refreshStep3Ui();
}
// pdf-mvp.js
// MVP raster PDF (canvas -> JPEG -> PDF) with damage_items listing from Config.DB.export.pdf.damage_item.*
// Keeps: centered title, photo grid cell 90x60mm, gapCol=1.5mm, gapRow=5mm.

const PdfMvp = {
  async generateMvpPdf({ config, state, photosById, dpi = 150 }) {
    const A4 = { wMm: 210, hMm: 297 };
    const pxPerMm = dpi / 25.4;

    const pageWpx = Math.round(A4.wMm * pxPerMm);
    const pageHpx = Math.round(A4.hMm * pxPerMm);

    const margin = { leftMm: 20, rightMm: 15, topMm: 25, bottomMm: 20 };
    const left = Math.round(margin.leftMm * pxPerMm);
    const right = Math.round(margin.rightMm * pxPerMm);
    const top = Math.round(margin.topMm * pxPerMm);
    const bottom = Math.round(margin.bottomMm * pxPerMm);

    const contentW = pageWpx - left - right;
    const contentH = pageHpx - top - bottom;

    const font12 = Math.round((12 * dpi) / 72);
    const font14 = Math.round((14 * dpi) / 72);
    const lh = Math.round(font12 * 1.35);

    const omitValues = new Set((config?.export?.pdf?.omit_values || []).map(String));

    const selectors = config?.inventory?.damage_item?.selectors;
    if (!selectors?.category?.field_id || !selectors?.element?.field_id || !selectors?.subelement?.field_id) {
      throw new Error("Config selectors missing for damage_item");
    }
    const fidCat = selectors.category.field_id;
    const fidEl = selectors.element.field_id;
    const fidSub = selectors.subelement.field_id;

    const fieldsById = new Map((config.fields || []).map(f => [f.id, f]));

    const cellMm = { w: 90, h: 60 };
    const gapColMm = 1.5;
    const gapRowMm = 5;

    const cellW = Math.round(cellMm.w * pxPerMm);
    const cellH = Math.round(cellMm.h * pxPerMm);
    const gapCol = Math.round(gapColMm * pxPerMm);
    const gapRow = Math.round(gapRowMm * pxPerMm);

    const cols = config?.export?.pdf?.damage_item?.photos_layout?.columns ?? 2;
    const maxPhotos = config?.export?.pdf?.damage_item?.photos_layout?.max_photos ?? 10;

    const titleParts = config?.export?.pdf?.damage_item?.title_parts || ["category", "element", "subelement"];
    const fieldsFromTemplate = !!config?.export?.pdf?.damage_item?.fields_from_template;

    // ---------- helpers ----------
    const mmToPx = (mm) => Math.round(mm * pxPerMm);

    const fmtDate = (iso) => {
      if (!iso || typeof iso !== "string") return "";
      const m = iso.match(/^(\d{4})-(\d{2})-(\d{2})$/);
      if (!m) return iso;
      return `${m[3]}.${m[2]}.${m[1]}`;
    };

    const choiceToText = (v) => {
      if (v == null) return "";
      if (typeof v === "string") return v;
      if (typeof v === "object") {
        const c = v.choice ?? v.Choice ?? v.choice_value;
        const o = v.other ?? v.Other ?? v.other_text;
        if (c === "Иное" && o) return String(o);
        if (c && o) return `${c}: ${o}`;
        if (c) return String(c);
      }
      return String(v);
    };

    const formatValue = (fieldDef, v) => {
      if (v == null) return "";
      if (!fieldDef) return choiceToText(v);

      if (fieldDef.type === "date") return fmtDate(String(v));
      if (fieldDef.type === "number") return (typeof v === "number" ? String(v) : String(Number(v)));
      if (fieldDef.type === "select") return choiceToText(v);

      if (fieldDef.type === "group_xy" && typeof v === "object") {
        const x = v.x, y = v.y, unit = v.unit;
        if (Number.isFinite(x) && Number.isFinite(y) && unit) return `${x} × ${y} ${unit}`;
        return "";
      }
      if (fieldDef.type === "group_xyz" && typeof v === "object") {
        const x = v.x, y = v.y, z = v.z, unit = v.unit;
        if (Number.isFinite(x) && Number.isFinite(y) && Number.isFinite(z) && unit) return `${x} × ${y} × ${z} ${unit}`;
        return "";
      }
      if (fieldDef.type === "photos") return ""; // never print as text

      return String(v);
    };

    function matchTemplate(damageItem) {
      const templates = config?.inventory?.damage_item?.templates || [];
    
      const getChoice = (v) => {
        if (v == null) return "";
        if (typeof v === "object") return String(v.choice ?? v.Choice ?? v.choice_value ?? "");
        return String(v);
      };
    
      const cat = getChoice(damageItem?.[fidCat] ?? damageItem?.category);
      const el  = getChoice(damageItem?.[fidEl]  ?? damageItem?.element);
      const sub = getChoice(damageItem?.[fidSub] ?? damageItem?.subelement);
    
      let best = null;
      let bestScore = -1;
    
      for (const t of templates) {
        const w = t?.when || {};
    
        if (w.category && String(w.category) !== cat) continue;
    
        // element
        if (w.element != null) {
          if (String(w.element) !== el) continue;
        } else if (Array.isArray(w.element_in)) {
          if (!w.element_in.map(String).includes(el)) continue;
        }
    
        // subelement
        if (w.subelement != null) {
          if (!sub) continue;
          if (String(w.subelement) !== sub) continue;
        } else if (Array.isArray(w.subelement_in)) {
          if (!sub) continue;
          if (!w.subelement_in.map(String).includes(sub)) continue;
        }
    
        // score: exact > *_in > none
        let score = 1;
        if (w.element != null) score += 2;
        else if (Array.isArray(w.element_in)) score += 1;
    
        if (w.subelement != null) score += 2;
        else if (Array.isArray(w.subelement_in)) score += 1;
    
        if (score > bestScore) { best = t; bestScore = score; }
      }
    
      return best;
    }    

    function buildDamageTitle(di) {
      const parts = [];
      for (const p of titleParts) {
        if (p === "category") parts.push(choiceToText(di?.[fidCat] ?? di?.category));
        else if (p === "element") parts.push(choiceToText(di?.[fidEl] ?? di?.element));
        else if (p === "subelement") parts.push(choiceToText(di?.[fidSub] ?? di?.subelement));        
      }
      return parts.filter(Boolean).join(" / ");
    }

    async function blobToImageBitmap(blob) {
      // blob may already be a Blob
      if (!(blob instanceof Blob)) throw new Error("photosById must contain Blob values");
      return await createImageBitmap(blob);
    }

    function drawWrappedText(ctx, text, x, y, maxW, lineH) {
      const s = String(text ?? "").trim();
      if (!s) return y + lineH; // ключевое: пустое значение всё равно занимает строку
    
      const words = s.split(/\s+/).filter(Boolean);
      let line = "";
    
      for (const w of words) {
        const test = line ? (line + " " + w) : w;
        if (ctx.measureText(test).width <= maxW) {
          line = test;
        } else {
          ctx.fillText(line, x, y);
          pageHasContent = true;
          y += lineH;
          line = w;
        }
      }
    
      if (line) {
        ctx.fillText(line, x, y);
        pageHasContent = true;
        y += lineH;
      }
      return y;
    }  
    function countWrappedLines(ctx, text, maxW) {
  const s = String(text ?? "").trim();
  if (!s) return 1;

  const words = s.split(/\s+/).filter(Boolean);
  let line = "";
  let lines = 0;

  for (const w of words) {
    const test = line ? (line + " " + w) : w;
    if (ctx.measureText(test).width <= maxW) {
      line = test;
    } else {
      lines += 1;
      line = w;
    }
  }
  if (line) lines += 1;
  return Math.max(1, lines);
}

function wrapWordsToLines(ctx, words, maxW) {
  const lines = [];
  let line = "";

  for (const w of words) {
    const test = line ? (line + " " + w) : w;
    if (ctx.measureText(test).width <= maxW) {
      line = test;
    } else {
      if (line) lines.push(line);
      line = w;
    }
  }
  if (line) lines.push(line);

  return lines;
}

  // ---------- page rendering ----------
const canvases = [];
let canvas = null;
let ctx = null;
let pageHasContent = false;
let pageNo = 0; // текущий номер СТРАНИЦЫ (первая будет 1, но цифру на ней не рисуем)

function drawPageNumberIfNeeded() {
  // Номера ставим начиная со 2-й страницы
  if (pageNo < 2) return;

  const oldFont = ctx.font;
  const oldAlign = ctx.textAlign;
  const oldBaseline = ctx.textBaseline;
  const oldFill = ctx.fillStyle;

  ctx.fillStyle = "#000";
  ctx.font = `${font12}px Arial, sans-serif`;
  ctx.textAlign = "center";
  ctx.textBaseline = "top";

  // по центру страницы
  const x = ctx.canvas.width / 2;

  // минимум 10 мм от верхнего края
  const y = mmToPx(10);

  ctx.fillText(String(pageNo), x, y);
  pageHasContent = true;

  ctx.font = oldFont;
  ctx.textAlign = oldAlign;
  ctx.textBaseline = oldBaseline;
  ctx.fillStyle = oldFill;
}

function newPage() {
  if (canvas && pageHasContent) {
  drawPageNumberIfNeeded();   // рисуем номер на текущей странице
  canvases.push(canvas);      // и только потом сохраняем страницу
}
pageNo += 1; // начинаем новую страницу: 1, 2, 3...

  canvas = document.createElement("canvas");
  canvas.width = pageWpx;
  canvas.height = pageHpx;

  // alpha:false + белая заливка = никаких “чёрных” страниц
  ctx = canvas.getContext("2d", { alpha: false });
  ctx.fillStyle = "#fff";
  ctx.fillRect(0, 0, pageWpx, pageHpx);
  ctx.fillStyle = "#000";

  pageHasContent = false;
  return { ctx, canvas };
}

newPage();

let cursorY = top;

function ensureSpace(needPx) {
  if (cursorY + needPx <= top + contentH) return false;
  newPage();
  cursorY = top;
  return true;
}

    // ----- header (keeps your earlier text decisions) -----
    ctx.fillStyle = "#000";

    // Center title block
    ctx.font = `bold ${font14}px Arial, sans-serif`;
    const title1 = "Акт осмотра №1";
    const title2 = "поврежденного имущества,";
    const polNum = (state?.f_policy_number ? String(state.f_policy_number) : "________");
    const polDate = (state?.f_policy_date ? fmtDate(String(state.f_policy_date)) : "__.__.____");
    const title3 = `застрахованного по Договору/Полису страхования № ${polNum} от ${polDate}.`;

    const centerX = left + contentW / 2;

    function drawCentered(line) {
      const w = ctx.measureText(line).width;
      ctx.fillText(line, centerX - w / 2, cursorY);
      pageHasContent = true;
      cursorY += lh;
    } 
    
    function drawPageNumberIfNeeded() {
  // номера ставим начиная со 2-й страницы
  if (pageNo < 2) return;

  // сохраняем старые настройки, чтобы не сломать остальной текст
  const oldFont = ctx.font;
  const oldAlign = ctx.textAlign;
  const oldBaseline = ctx.textBaseline;
  const oldFill = ctx.fillStyle;

  ctx.fillStyle = "#000";
  ctx.font = `${font12}px Arial, sans-serif`;
  ctx.textAlign = "center";
  ctx.textBaseline = "top";

  // по центру страницы (не по центру контента!)
  const x = ctx.canvas.width / 2;

  // 10 мм от верхнего края
  const y = mmToPx(10);

  ctx.fillText(String(pageNo), x, y);
  pageHasContent = true;

  // вернуть настройки
  ctx.font = oldFont;
  ctx.textAlign = oldAlign;
  ctx.textBaseline = oldBaseline;
  ctx.fillStyle = oldFill;
}

    drawCentered(title1);
    ctx.font = `${font12}px Arial, sans-serif`;
    drawCentered(title2);
    drawCentered(title3);

    cursorY += lh; // small gap

    ctx.font = `${font12}px Arial, sans-serif`;

    const headerRows = [
      ["Дата осмотра:", fmtDate(state?.f_inspection_date)],
      ["Место осмотра:", state?.f_inspection_address || ""],
      ["Страхователь:", state?.f_insurer || ""],
      ["Представитель страхователя:", state?.f_insurer_rep || ""],
      ["Дата события:", fmtDate(state?.f_event_date)],
      ["Описание события и причины:", state?.f_event_circumstances || ""]
          ];

    
    for (const [label, value] of headerRows) {
  const x = left;

  const labelText = String(label ?? "");
  const valueText = String(value ?? "");

  // 1) меряем ширину заголовка жирным (чтобы понять, где начинается значение)
  ctx.font = `700 ${font12}px Arial, sans-serif`;
  const labelW = ctx.measureText(labelText + " ").width;

  const gap = mmToPx(2);               // маленький зазор после двоеточия
  const valX = x + labelW + gap;       // вот тут начинается значение
  const valW = (x + contentW) - valX;  // сколько места осталось под значение

  // Если вдруг заголовок получился слишком длинный и места под значение почти нет —
  // рисуем значение с новой строки (это редкий защитный случай)
  if (valW < mmToPx(40)) {
    ensureSpace(lh * 2);

    // заголовок жирным на отдельной строке
    ctx.font = `700 ${font12}px Arial, sans-serif`;
    cursorY = drawWrappedText(ctx, labelText, x, cursorY, contentW, lh);

    // значение обычным на следующей строке
    ctx.font = `${font12}px Arial, sans-serif`;
    cursorY = drawWrappedText(ctx, valueText, x, cursorY, contentW, lh);

    continue;
  }

  // 2) считаем реальную высоту значения (сколько строк) и переносим страницу, если надо
  ctx.font = `${font12}px Arial, sans-serif`;
  const linesVal = countWrappedLines(ctx, valueText, valW);
  ensureSpace(linesVal * lh);

  // 3) рисуем заголовок жирным
  ctx.font = `700 ${font12}px Arial, sans-serif`;
  ctx.fillText(labelText, x, cursorY);
  pageHasContent = true;

// 4) значение: первая строка — после заголовка, переносы — с левого края
ctx.font = `${font12}px Arial, sans-serif`;

const words = valueText.trim() ? valueText.trim().split(/\s+/) : [];
let firstLine = "";
let used = 0;

// собираем первую строку так, чтобы она влезла в valW (после заголовка)
for (let i = 0; i < words.length; i++) {
  const test = firstLine ? (firstLine + " " + words[i]) : words[i];
  if (ctx.measureText(test).width <= valW) {
    firstLine = test;
    used = i + 1;
  } else {
    break;
  }
}

// остальное переносим, но уже на всю ширину (с левого края)
const restWords = words.slice(used);
const restLines = wrapWordsToLines(ctx, restWords, contentW);

// считаем реальную высоту: 1 строка (firstLine) + restLines
const totalLines = Math.max(1, (firstLine ? 1 : 0) + restLines.length);
ensureSpace(totalLines * lh);

// рисуем первую строку значения после заголовка
if (firstLine) {
  ctx.fillText(firstLine, valX, cursorY);
  pageHasContent = true;
} else {
  // если значение пустое — рисуем ничего, но строку считаем
}

cursorY += lh;

// переносы значения — с самого левого края
for (const line of restLines) {
  ctx.fillText(line, x, cursorY);
  pageHasContent = true;
  cursorY += lh;
}

}  

    cursorY += lh;

    // ----- damage items list -----
    ctx.font = `bold ${font12}px Arial, sans-serif`;
    ctx.fillText("Перечень поврежденного имущества:", left, cursorY);
    pageHasContent = true;
    cursorY += lh * 1.2;

    const items = Array.isArray(state?.damage_items) ? state.damage_items : [];

if (!items.length) {
  ctx.font = `${font12}px Arial, sans-serif`;
  ctx.fillText("Нет повреждений", left, cursorY);
  pageHasContent = true;
  cursorY += lh;
} else {
  for (let i = 0; i < items.length; i++) {
    const di = items[i] || {};
    const title = buildDamageTitle(di) || `Повреждение ${i + 1}`;

    // Title
    ensureSpace(lh * 2);
    ctx.font = `bold ${font12}px Arial, sans-serif`;
    ctx.fillText(`${i + 1}) ${title}`, left, cursorY);
    pageHasContent = true;
    cursorY += lh;

    // Fields from template
    if (fieldsFromTemplate) {
      const tmpl = matchTemplate(di);
      const tFields = (tmpl?.fields || []).map(x => x.field_id);

      // печатаем только реальные значения, кроме селекторов и photos
      for (const fid of tFields) {
        if (fid === fidCat || fid === fidEl || fid === fidSub) continue;
        if (fid === "f_photos") continue;

        const def = fieldsById.get(fid);
        const raw = di[fid];
        const textVal = formatValue(def, raw);

        if (!textVal) continue;
        if (omitValues.has(textVal)) continue;

        ensureSpace(lh * 2);
        ctx.font = `${font12}px Arial, sans-serif`;
        const label = def?.label ? `${def.label}: ` : `${fid}: `;
        const labelW = ctx.measureText(label).width;
        const maxW = contentW - labelW;

        ctx.fillText(label, left, cursorY);
        pageHasContent = true;
        cursorY = drawWrappedText(ctx, textVal, left + labelW, cursorY, maxW, lh);
      }
    }

    // Photos
    const photoIds = Array.isArray(di.f_photos) ? di.f_photos : (Array.isArray(di.photo_ids) ? di.photo_ids : []);
    const ids = photoIds.slice(0, maxPhotos);

    if (ids.length) {
      cursorY += Math.round(lh * 0.5);


      // --- grid layout (safe; correct page breaks) ---
      let effCellW = cellW;
      const maxCellW = Math.floor((contentW - (cols - 1) * gapCol) / cols);
      if (effCellW > maxCellW) effCellW = maxCellW;

      const gridWpx = cols * effCellW + (cols - 1) * gapCol;
      let startX = left + Math.round((contentW - gridWpx) / 2);
      if (startX < left) startX = left;

      let gridTopY = cursorY;
      let col = 0;
      let row = 0;

      for (let p = 0; p < ids.length; p++) {
        const pid = ids[p];
        const blob = photosById?.get(pid);
        if (!blob) continue;

        // вычисляем координаты для текущей страницы
        let x = startX + col * (effCellW + gapCol);
        let y = gridTopY + row * (cellH + gapRow);

        // если по высоте не помещается — новая страница, сетка начинается заново
        if (y + cellH > top + contentH) {
          newPage();
          cursorY = top;

          gridTopY = cursorY;
          col = 0;
          row = 0;

          x = startX;
          y = gridTopY;
        }

        const bmp = await blobToImageBitmap(blob);

        // contain fit
        const scale = Math.min(effCellW / bmp.width, cellH / bmp.height);
        const dw = Math.round(bmp.width * scale);
        const dh = Math.round(bmp.height * scale);
        const dx = x + Math.round((effCellW - dw) / 2);
        const dy = y + Math.round((cellH - dh) / 2);

        ctx.fillStyle = "#fff";
        ctx.fillRect(x, y, effCellW, cellH);
        ctx.drawImage(bmp, dx, dy, dw, dh);
        

        pageHasContent = true;

        col++;
        if (col >= cols) { col = 0; row++; }
      }
     
      ctx.fillStyle = "#000"; // вернуть цвет текста, иначе следующий текст будет белым

      // cursorY — в конец сетки на последней странице
      const usedRows = row + (col > 0 ? 1 : 0);
      cursorY = gridTopY + usedRows * cellH + Math.max(0, usedRows - 1) * gapRow;
    }

    // дополнительный отступ после фото перед следующим повреждением
const afterPhotosGap = mmToPx(6); // ~6 мм (можно 5-8 мм)
ensureSpace(afterPhotosGap);
cursorY += afterPhotosGap;

    cursorY += lh; // важный зазор между повреждениями
  }
}


if (canvas && pageHasContent) {
  drawPageNumberIfNeeded();
  canvases.push(canvas);
}

    // ---------- canvas -> jpeg bytes ----------
    const jpegPages = [];
    for (const c of canvases) {
      const blob = await new Promise((res) => c.toBlob(res, "image/jpeg", 0.92));
      const ab = await blob.arrayBuffer();
      jpegPages.push({ bytes: new Uint8Array(ab), wPx: c.width, hPx: c.height });
    }

    // ---------- build PDF from JPEG pages ----------
    const pdfBytes = buildPdfFromJpegs(jpegPages, A4, dpi);
    const pdfBlob = new Blob([pdfBytes], { type: "application/pdf" });
    return { pdfBlob };
  }
};

// Minimal multi-page PDF builder (each page is full-page JPEG)
function buildPdfFromJpegs(jpegPages, A4, dpi) {
  const ptPerIn = 72;
  const wPt = (A4.wMm / 25.4) * ptPerIn;
  const hPt = (A4.hMm / 25.4) * ptPerIn;

  const enc = (s) => new TextEncoder().encode(s);

  const parts = [];
  let offset = 0;

  const objOffsets = []; // index = obj number
  const addBytes = (u8) => { parts.push(u8); offset += u8.length; };
  const addStr = (s) => addBytes(enc(s));

  const beginObj = (n) => { objOffsets[n] = offset; addStr(`${n} 0 obj\n`); };
  const endObj = () => addStr(`endobj\n`);

  const writeStreamObj = (n, dictStr, streamBytes) => {
    beginObj(n);
    addStr(`<< ${dictStr} /Length ${streamBytes.length} >>\nstream\n`);
    addBytes(streamBytes);
    addStr(`\nendstream\n`);
    endObj();
  };

  // Object numbering:
  // 1 Catalog, 2 Pages
  // For each page: Page, Contents, Image  => 3 objects per page
  const pageCount = jpegPages.length;
  const pageObj = [];
  const contentsObj = [];
  const imageObj = [];
  let nextObj = 3;

  for (let i = 0; i < pageCount; i++) {
    pageObj.push(nextObj++);
    contentsObj.push(nextObj++);
    imageObj.push(nextObj++);
  }

  const maxObj = nextObj - 1;
  const size = maxObj + 1;

  // PDF header
  addStr("%PDF-1.3\n%\xE2\xE3\xCF\xD3\n");

  // 1: Catalog
  beginObj(1);
  addStr(`<< /Type /Catalog /Pages 2 0 R >>\n`);
  endObj();

  // 2: Pages root
  const kids = pageObj.map(n => `${n} 0 R`).join(" ");
  beginObj(2);
  addStr(`<< /Type /Pages /Count ${pageCount} /Kids [ ${kids} ] >>\n`);
  endObj();

  // Per-page objects
  for (let i = 0; i < pageCount; i++) {
    const imName = `Im${i + 1}`;

    // Contents stream: draw image full page
    const contentStr =
      `q\n${wPt.toFixed(2)} 0 0 ${hPt.toFixed(2)} 0 0 cm\n/${imName} Do\nQ\n`;
    const contentBytes = enc(contentStr);
    writeStreamObj(contentsObj[i], ``, contentBytes);

    // Image XObject stream (JPEG)
    const jpg = jpegPages[i].bytes;
    const imgDict =
      `/Type /XObject /Subtype /Image /Name /${imName} ` +
      `/Width ${jpegPages[i].wPx} /Height ${jpegPages[i].hPx} ` +
      `/ColorSpace /DeviceRGB /BitsPerComponent 8 /Filter /DCTDecode`;
    writeStreamObj(imageObj[i], imgDict, jpg);

    // Page object
    beginObj(pageObj[i]);
    addStr(
      `<< /Type /Page /Parent 2 0 R ` +
      `/MediaBox [0 0 ${wPt.toFixed(2)} ${hPt.toFixed(2)}] ` +
      `/Resources << /XObject << /${imName} ${imageObj[i]} 0 R >> >> ` +
      `/Contents ${contentsObj[i]} 0 R >>\n`
    );
    endObj();
  }

  // xref
  const xrefStart = offset;
  addStr("xref\n");
  addStr(`0 ${size}\n`);
  addStr("0000000000 65535 f \n");

  for (let i = 1; i < size; i++) {
    const off = objOffsets[i] || 0;
    addStr(String(off).padStart(10, "0") + " 00000 n \n");
  }

  // trailer
  addStr(
    `trailer\n<< /Size ${size} /Root 1 0 R >>\nstartxref\n${xrefStart}\n%%EOF\n`
  );

  // concat parts
  const out = new Uint8Array(offset);
  let pos = 0;
  for (const p of parts) { out.set(p, pos); pos += p.length; }
  return out;
}

function renderStep4(root, cfg, st) {
  root.appendChild(el("div", { text:"Шаг 4: Финализация", style:"font-weight:800; font-size:16px;" }));

  const items = Array.isArray(st?.damage_items) ? st.damage_items : [];
  const totalPhotos = items.reduce((acc, di) => acc + (Array.isArray(di?.f_photos) ? di.f_photos.length : 0), 0);

  root.appendChild(el("div", { class:"muted", style:"margin-top:6px;", text:`Повреждений: ${items.length}, Фото: ${totalPhotos}` }));

    // -------------------------------
  // Кратко по акту (на Финализации)
  // -------------------------------
  const fieldsById = indexFieldsById(cfg);
  const form = st?.form || {};

  const fmtChoice = (v) => {
    if (v == null) return "";
    if (typeof v === "string") return v.trim();
    if (typeof v === "object") {
      const c = v.choice ?? v.Choice;
      const o = v.other ?? v.Other;
      if (c === "Иное" && o) return String(o).trim();
      if (c) return String(c).trim();
    }
    return String(v).trim();
  };

  const summaryCard = el("div", { class:"card", style:"margin-top:10px;" });
  summaryCard.appendChild(el("div", {
    text:"Кратко по акту",
    style:"font-weight:800; margin-bottom:8px;"
  }));

  const row = (label, value) => el("div", { class:"row" }, [
    el("div", { style:"font-weight:700;", text: label + ":" }),
    el("div", { text: value || "—" })
  ]);

  const insurerLabel = fieldsById.get("f_insurer")?.label || "Страхователь";
  const repLabel = fieldsById.get("f_insurer_rep")?.label || "Представитель страхователя";
  const eventDateLabel = fieldsById.get("f_event_date")?.label || "Дата события";

  const insurerVal = fmtChoice(form.f_insurer);
  const repVal = fmtChoice(form.f_insurer_rep);
  const eventDateVal = form.f_event_date ? fmtDateRu(String(form.f_event_date)) : "";

  summaryCard.appendChild(row(insurerLabel, insurerVal));
  summaryCard.appendChild(row(repLabel, repVal));
  summaryCard.appendChild(row(eventDateLabel, eventDateVal));

  // Повреждения: "Категория / Элемент / Подэлемент"
  summaryCard.appendChild(el("div", { style:"margin-top:10px; font-weight:700;", text:"Повреждения:" }));

  const ol = el("ol", { style:"margin:6px 0 0 18px;" });

  const itemsNow = Array.isArray(st?.damage_items) ? st.damage_items : [];
  for (let i = 0; i < itemsNow.length; i++) {
    const di = itemsNow[i] || {};
    const cat = fmtChoice(di.f_damage_category);
    const elv = fmtChoice(di.f_damage_element);
    const sub = fmtChoice(di.f_damage_subelement);

    const parts = [cat, elv, sub].filter(Boolean);
    const line = parts.length ? parts.join(" / ") : "—";

    ol.appendChild(el("li", { text: line }));
  }

  if (!itemsNow.length) {
    ol.appendChild(el("li", { text:"—" }));
  }

  summaryCard.appendChild(ol);

  // быстрые кнопки, чтобы вернуться и исправить
  summaryCard.appendChild(el("div", { class:"actions", style:"margin-top:10px;" }, [
    el("button", { type:"button", text:"✎ Редактировать анкету (Шаг 1)", onclick: () => Store.update(d => { d.stepId = "step1"; }) }),
    el("button", { type:"button", text:"＋ Добавить повреждение (Шаг 2)", onclick: () => Store.update(d => { d.stepId = "step3"; }) }),
    el("button", { type:"button", text:"☰ Список повреждений (Шаг 3)", onclick: () => Store.update(d => { d.stepId = "step2"; }) })
  ]));

  root.appendChild(summaryCard);

  
  // -------------------------------
  // PDF (Акт осмотра):
  // формируем незаметно для клиента при нажатии кнопок снизу
  // -------------------------------
  const buildPdfFileName = (stateForPdf) => {
    const iso = (stateForPdf?.f_inspection_date || new Date().toISOString().slice(0,10));
    const d = String(iso).replaceAll("-", "");
    const pol = (stateForPdf?.f_policy_number ? String(stateForPdf.f_policy_number) : "акт")
      .replace(/[^\w\-]+/g, "_")
      .slice(0, 40);
    return `Акт_осмотра_${pol}_${d}.pdf`;
  };

  const makePdf = async (btn) => {
    btn.disabled = true;
    try {
      const stNow = Store.get();
      const stateForPdf = { ...(stNow.form || {}), damage_items: (stNow.damage_items || []) };

      // собираем нужные photoId (уважаем max_photos на повреждение)
      const maxPerItem =
        cfg?.export?.pdf?.damage_item?.photos_layout?.max_photos ??
        cfg?.constraints?.photos?.max_per_damage_item ??
        10;

      const ids = [];
      const seen = new Set();
      for (const di of (stateForPdf.damage_items || [])) {
        const arr = Array.isArray(di?.f_photos) ? di.f_photos : [];
        for (const pid of arr.slice(0, maxPerItem)) {
          if (!pid || seen.has(pid)) continue;
          seen.add(pid);
          ids.push(pid);
        }
      }

      // читаем blobs из IDB
      const photosById = new Map();
      let done = 0;
      if (ids.length) setStatus(`Формируем акт: загрузка фото ${done}/${ids.length}`, "ok");

      for (const pid of ids) {
        const rec = await Persistence.getImageRecord(pid);
        if (rec?.blob) photosById.set(pid, rec.blob);
        done++;
        if (ids.length && (done % 2 === 0 || done === ids.length)) {
          setStatus(`Формируем акт: загрузка фото ${done}/${ids.length}`, "ok");
        }
      }

      if (ids.length) setStatus("Формируем акт: генерация PDF…", "ok");

      const { pdfBlob } = await PdfMvp.generateMvpPdf({
        config: cfg,
        state: stateForPdf,
        photosById
      });

      const fileName = buildPdfFileName(stateForPdf);
      await Persistence.savePdfRecord({ blob: pdfBlob, pdfId:"last", fileName });

      setStatus("Акт осмотра сформирован.", "ok");
      return { pdfBlob, fileName };
    } catch (e) {
      console.error(e);
      setStatus("Ошибка формирования акта: " + (e?.message || String(e)), "err");
      throw e;
    } finally {
      btn.disabled = false;
    }
  };

  const dlBtn = el("button", { type:"button", class:"primary", text:"Скачать Акт осмотра" });
  dlBtn.addEventListener("click", async () => {
    try {
      const { pdfBlob, fileName } = await makePdf(dlBtn);
      downloadBlob(pdfBlob, fileName);
    } catch {}
  });

  const shBtn = el("button", { type:"button", text:"Направить Акт осмотра в АО \"СОГАЗ\"" });
  shBtn.addEventListener("click", async () => {
    try {
      const { pdfBlob, fileName } = await makePdf(shBtn);

      // Если share недоступен — просто скачиваем.
      if (!navigator.share) {
        downloadBlob(pdfBlob, fileName);
        return;
      }

      try {
        const file = new File([pdfBlob], fileName, { type:"application/pdf" });
        // canShare бывает не везде — проверяем аккуратно
        if (navigator.canShare && !navigator.canShare({ files:[file] })) {
          downloadBlob(pdfBlob, fileName);
          return;
        }
        await navigator.share({ files:[file], title:fileName, text:"Акт осмотра (PDF)" });
      } catch (e) {
        // если share не сработал — fallback на скачивание
        downloadBlob(pdfBlob, fileName);
      }
    } catch {}
  });

  const footerRow = el("div", { class:"actions" }, [dlBtn, shBtn]);
  StickyFooter.set(footerRow);
  root.appendChild(document.createComment("actions-mounted-in-stickyFooter"));
}
function renderUnknownStep(root, step) {
    root.appendChild(el("div", { class:"err", text:`Неизвестный шаг: ${step?.id || "?"}` }));
  }

  // ===============================
  // Wire UI events
  // ===============================
  $("resetBtn").addEventListener("click", async () => {
  const st = Store.get();
  const cfg = st?.config || null;

  const ok = confirm("Начать новый осмотр? Текущие данные осмотра и фото будут удалены.");
  if (!ok) return;

  await Persistence.clearInspectionData();
  ImagePipeline.clearThumbs();

  Store.set(Object.freeze({
    config: cfg,
    stepId: cfg?.ui?.steps?.[0]?.id || "step1",
    form: {},
    damage_items: [],
    current_damage_index: null,
  }));
});

$("configFile").addEventListener("change", async () => {
  const file = $("configFile").files?.[0];
  if (!file) return;

  try {
    const cfg = await readJsonFile(file);
    const errs = validateConfigBasic(cfg);
    if (errs.length) {
      setStatus("Ошибка в Config.DB: " + errs.join("; "), "err");
      return;
    }

    await Persistence.saveConfig(cfg);
    await Persistence.clearInspectionData();

    Store.set(Object.freeze({
      config: cfg,
      stepId: cfg.ui.steps[0]?.id || "step1",
      form: {},
      damage_items: [],
      current_damage_index: null,
    }));

    // ✅ ШАГ 3 — rules engine
    initRulesEngine(cfg);
    if (__rulesErrors?.length) console.warn("Rules engine warnings/errors:", __rulesErrors);

    // ✅ ШАГ 3.2 — image pipeline
    ImagePipeline.clearThumbs();
    try { await ImagePipeline.init(cfg); } catch (e) { console.error(e); }

    // чтобы можно было импортировать тот же файл повторно
    $("configFile").value = "";

    setStatus("Config импортирован и применён.", "ok");
  } catch (e) {
    setStatus("Не удалось прочитать JSON: " + (e?.message || String(e)), "err");
    console.error(e);
  }
});

  // ===============================
  // Startup restore (IndexedDB)
  // ===============================
  try {
    await Persistence.init();
    const restored = await Persistence.load();
    let cfg = restored?.config || null;

// Если в памяти нет config — пробуем взять встроенный из textarea
if (!cfg) {
  const raw = document.getElementById("embeddedConfig")?.value?.trim();
  if (raw) {
    try {
      const parsed = JSON.parse(raw);

      const errs = validateConfigBasic(parsed);
      if (errs.length) {
        setStatus("Встроенный Config.DB содержит ошибки: " + errs.join("; "), "err");
      } else {
        cfg = parsed;
        await Persistence.saveConfig(cfg);
        setStatus("Использую встроенный Config.DB (первый запуск).", "ok");
      }
    } catch (e) {
      setStatus("Не удалось распарсить встроенный Config.DB: " + (e?.message || String(e)), "err");
      console.error(e);
    }
  }
}

// Если config нашли (из IDB или встроенный) — поднимаем приложение
if (cfg) {
  initRulesEngine(cfg);
Store.set(Object.freeze({
    config: cfg,
    stepId: restored?.app?.stepId ?? (cfg?.ui?.steps?.[0]?.id || null),
    form: restored?.app?.form || {},
    damage_items: restored?.app?.damage_items || [],
    current_damage_index: restored?.app?.current_damage_index ?? null,
  }), { skipRender: true });
  try { await ImagePipeline.init(cfg); } catch (e) { console.error(e); }

  const n = document.getElementById("persistLine");
  if (n) n.textContent = restored?.config ? "Восстановлено из памяти" : "Config встроен в приложение";
}

  } catch (e) {
    console.warn("Persistence init/restore failed:", e);
  }
// Debug helper (временное): доступ из консоли DevTools
window.__osmotrum = { Store, Persistence };

  // initial render + subscribe
  Store.subscribe(render);
  render();
</script>
</body>
</html>
